# Raspberry Pi Camera Server

FastAPI-based camera server that exposes both MJPEG video feeds and JPEG snapshot
endpoints for multiple USB or Raspberry Pi cameras. Each camera can be
optionally mapped to its own port through an autogenerated Nginx config while a
central API handles configuration and a simple front-end viewer.

Typical uses include:

- Home or office surveillance with per-room ports you can bookmark or embed elsewhere
- Lab or workshop monitoring where each microscope/sensor camera is reachable on a predictable URL
- Demo stations or kiosks that expose MJPEG feeds to browsers or digital signage players

## Features
- Background frame grabber per camera using OpenCV
- MJPEG video and snapshot endpoints per camera via `http://<host>:<port>/` and `/snapshot` (Nginx proxy)
- Central FastAPI app with configuration APIs and built-in viewer
- Integrated web UI with camera dashboard, settings editor, and API reference
- JSON-based configuration persisted to `cameras.json`
- Hot reload of camera capture threads and regenerated Nginx mapping when configuration is updated via the API
- Camera discovery endpoint to list connected devices and avoid assigning the same camera twice
- Optional per-camera capture settings (resolution, FPS, brightness, exposure, and white balance)
- Snapshot responses fall back to an inline "offline" placeholder instead of errors
- Optional HTTP basic auth for configuration endpoints (toggleable in the Settings UI or JSON config)
- Manual restart button per camera on the dashboard plus a `POST /api/cameras/{id}/restart` endpoint for recovery
- /health endpoint plus Prometheus-style /metrics gauges for availability, subscribers, and frame ages


## Automatic Installation

This one‑liner downloads the script and executes it.

```bash
bash -c "$(curl -fsSL https://raw.githubusercontent.com/hastla007/rpicamserver/main/install.sh)"
```




## Getting started - Manual Installation

### Install dependencies
Install system prerequisites for OpenCV (varies by distro) and the Python
packages:

```bash
sudo apt update
sudo apt install python3-opencv python3-pip
pip3 install -r requirements.txt
```

### Configure cameras
Create a `cameras.json` file describing your devices. You can start from the
included example:

```bash
cp cameras.example.json cameras.json
```

Update each camera entry to point to the correct device index and (optionally)
choose a port for the Nginx-mapped endpoints. Device indices map to `/dev/video*`
devices on most Linux systems. Ports are auto-assigned starting at 8081 if
omitted. You can also set `width`, `height`, and `fps` to request a specific
capture resolution and frame rate for each camera, plus optional `brightness`,
`exposure`, and `white_balance` controls when supported by the device driver.
If you want to guard the Settings/API endpoints, include an `auth` block with
`enabled`, `username`, and `password`. Set `protect_streams` to `true` to require
the same credentials on `/cam/{id}/video` and `/cam/{id}/snapshot`; otherwise
streams stay open by default. Validation errors in the `auth` block are surfaced
as `auth_error` instead of silently disabling auth.

### Run the server
Start the main FastAPI control plane (defaults to port 8000; override with
`APP_PORT=<port>`):

```bash
uvicorn app:app --host 0.0.0.0 --port 8000
```

On startup the app loads `cameras.json`, spins up background frame grabbers, and
generates `nginx.cameras.conf` that maps per-camera ports to the main API
streams. Visit `http://<host>:8000/` for the built-in viewer. Use the
navigation to jump between the live camera dashboard, the Settings page (to add
or edit cameras), and the API Docs page for endpoint details.

If your browser or environment blocks the built-in UI (e.g., locked-down
Chromium policies), you can still manage the server headlessly:

- Read config: `curl http://<host>:8000/api/cameras`
- Discover devices: `curl 'http://<host>:8000/api/devices?probe_missing=false'`
- Apply config: `curl -X POST http://<host>:8000/api/cameras -H 'Content-Type: application/json' -d @cameras.json`
- Check status: `curl http://<host>:8000/health`
- Scrape metrics: `curl http://<host>:8000/metrics`
- Delete a camera: `curl -X DELETE http://<host>:8000/api/cameras/<id>`
- Use the bundled helper: `python cli.py devices --no-probe-missing` or `python cli.py set cameras.json`

### Apply Nginx mapping

After the app starts, include the generated `nginx.cameras.conf` from your Nginx
configuration (for example, drop it into `/etc/nginx/conf.d/`). Then reload
Nginx:

```bash
sudo cp nginx.cameras.conf /etc/nginx/conf.d/cameras.conf
sudo systemctl reload nginx
```

Each camera will now be reachable via its configured port, e.g.:

- Video: `http://<host>:8081/`
- Snapshot: `http://<host>:8081/snapshot`

Nginx routing is a simple port fan-out to the FastAPI backend (default port 8000):

```
[Camera clients]
      | (ports 8081, 8082, ...)
   [Nginx proxy]
      | (proxied paths / and /snapshot)
   [FastAPI app :8000] -> /cam/<id>/video and /cam/<id>/snapshot
```

### Configure via API
You can update cameras at runtime with a POST to `/api/cameras`:

```bash
curl -X POST http://<host>:8000/api/cameras \
  -H "Content-Type: application/json" \
  -d '{
    "host": "0.0.0.0",
    "cameras": [
      {"id": "cam1", "name": "USB Cam 1", "device": 0, "port": 8081, "width": 1280, "height": 720, "fps": 30, "brightness": 0.5, "exposure": -4, "white_balance": 4500},
      {"id": "cam2", "name": "USB Cam 2", "device": 1, "port": 8082}
    ]
  }'
```

The server saves the configuration, restarts background capture threads, and
regenerates the Nginx mapping file.

You can discover attached cameras (and which ones are already assigned) with
`GET /api/devices`, which powers the Settings page picker.

## API overview

- `GET /` – Camera dashboard viewer
- `GET /settings` – UI for editing cameras and regenerating config
- `GET /api-docs` – HTML API reference shown in the UI
- `GET /api/cameras` – Return current configuration JSON
- `POST /api/cameras` – Persist configuration, restart captures, regenerate Nginx map
- `GET /api/devices` – Enumerate detected video devices and flag ones already configured. Query params: `max` to cap the probe range (defaults to `MAX_DEVICE_PROBE`, 4), and `probe_missing=true` to force probing when no `/dev/video*` nodes are present (defaults to off).
- `GET /cam/{id}/video` – MJPEG video stream for camera `{id}`
- `GET /cam/{id}/snapshot` – Single JPEG frame for camera `{id}`
- `GET /health` – JSON status of each configured camera (online/offline/stale with last-frame ages)
- `GET /metrics` – Prometheus-style gauges for camera availability and subscriber counts
- `POST /api/cameras/{id}/restart` – request a manual reopen for a camera that is offline or stale

Camera control ranges: brightness expects `0.0–1.0`, exposure `0–10000` (device-specific), and white balance `0–12000` Kelvin (0 usually means auto). Leave them blank for auto, and the server will reject values outside these bounds with a combined error message.

### Security

- Basic auth (disabled by default) protects `/settings`, `/api/cameras`, and `/api/devices`. Configure it from the Settings page or by adding an `auth` block to `cameras.json`.
- Streaming endpoints remain public; frontends or reverse proxies can add their own guards if needed.

### Logging and discovery controls

- `LOG_DEST` (comma-separated) chooses logging sinks: `stdout`, `file`, `syslog`. Defaults to `stdout`. Provide `LOG_FILE` when including `file`.
- `LOG_LEVEL` controls verbosity (defaults to `INFO`).
- `CAMERA_RETRY_INTERVAL` controls how often a failed camera reopen is attempted (seconds, default `30`). Offline cameras stay routable and return placeholders until they recover.
- `MAX_DEVICE_PROBE` caps how many numeric device indices are probed when no `/dev/video*` entries are present (default `4`).
- `PROBE_WHEN_NO_DEVICES` (true/false) toggles probing numeric indices when globbing finds nothing (default `false` to avoid CPU churn in containerized environments).
- The Settings UI surfaces the probe toggle and limit so you can avoid deep scans on systems without `/dev/video*` entries, and it skips auto-probing when the defaults disable it.

## Testing and CI

- Run unit tests locally with `pytest`.
- Lint the codebase with `ruff check .` (configured to ignore long HTML lines).
- GitHub Actions runs both linting and tests on pushes and pull requests via `.github/workflows/ci.yml`.

## Packaging and deployment

### Docker

Build and run the containerized server:

```bash
docker build -t rpicamserver .
docker run --rm -p 8000:8000 -p 8081-8090:8081-8090 \
  -v $(pwd)/cameras.json:/app/cameras.json \
  rpicamserver
```

Update the published ports to cover the range you plan to use. The container
runs `uvicorn app:app` on port 8000 and generates `nginx.cameras.conf` inside
the container.

### systemd service

An example service file is provided at `systemd/rpicamserver.service`. Copy the
project to `/opt/rpicamserver`, adjust the `User`, `Group`, and `APP_PORT`
environment variables as needed, then enable and start:

```bash
sudo cp systemd/rpicamserver.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable --now rpicamserver
```

## Licensing & contributions

This project is distributed under the [MIT License](LICENSE). Contributions are
welcome—please open an issue or pull request describing your change and the use
case it addresses.

## Notes
- OpenCV requires access to camera devices; ensure the user running the server
  has permissions for `/dev/video*`.
- If a camera fails to start, the server logs the error and continues with the
  remaining devices. Capture threads monitor failures and attempt automatic
  restarts when reads fail repeatedly.
- Streaming endpoints are async-based so multiple clients can connect without
  blocking, and capture threads pause when no subscribers are connected to save
  CPU.
- Snapshots return an inline placeholder JPEG (respecting the configured
  resolution where possible) when a camera is offline instead of a 503 error,
  which keeps dashboards from breaking while devices reconnect.
- Logging destinations are configurable via `LOG_DEST`; syslog is only enabled when requested and `/dev/log` is reachable.
- You can also run `python app.py` to start uvicorn with default settings.
