"""
Raspberry Pi camera server exposing MJPEG video and snapshot endpoints per camera.

Run with uvicorn:
    uvicorn app:app --reload --host 0.0.0.0 --port 8000

The main FastAPI app provides configuration APIs and a basic viewer. Per-camera
ports are made available via an autogenerated Nginx configuration mapping to the
central FastAPI endpoints.
"""

import json
import os
import threading
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

import cv2
import uvicorn
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, Response, StreamingResponse
from pydantic import BaseModel, Field

CONFIG_PATH = Path("cameras.json")
NGINX_CONFIG_PATH = Path("nginx.cameras.conf")
DEFAULT_CAMERA_HOST = "0.0.0.0"
DEFAULT_START_PORT = 8081
APP_PORT = int(os.getenv("APP_PORT", "8000"))

app = FastAPI(title="Raspberry Pi Camera Server")


###############################################################################
# Camera capture
###############################################################################


class Camera:
    """Background frame grabber for a single video device."""

    def __init__(self, device_index: int):
        self.device_index = device_index
        self.cap = cv2.VideoCapture(device_index)
        if not self.cap.isOpened():
            raise RuntimeError(f"Could not open camera device {device_index}")

        self.frame_lock = threading.Lock()
        self.latest_frame = None
        self.running = True

        self.thread = threading.Thread(target=self._update_loop, daemon=True)
        self.thread.start()

    def _update_loop(self) -> None:
        while self.running:
            ret, frame = self.cap.read()
            if not ret:
                time.sleep(0.1)
                continue

            with self.frame_lock:
                self.latest_frame = frame
            time.sleep(1 / 30.0)

    def get_frame(self):
        with self.frame_lock:
            if self.latest_frame is None:
                return None
            return self.latest_frame.copy()

    def stop(self) -> None:
        self.running = False
        self.thread.join(timeout=1)
        self.cap.release()


def _encode_frame(frame, quality: int = 80) -> Optional[bytes]:
    ret, jpeg = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), quality])
    if not ret:
        return None
    return jpeg.tobytes()


###############################################################################
# Configuration
###############################################################################


def default_config() -> Dict[str, Any]:
    return {"host": DEFAULT_CAMERA_HOST, "cameras": []}


def load_config() -> Dict[str, Any]:
    if CONFIG_PATH.exists():
        config = json.loads(CONFIG_PATH.read_text())
    else:
        config = default_config()

    assigned_cameras = assign_ports(config.get("cameras", []))
    if assigned_cameras != config.get("cameras", []):
        config["cameras"] = assigned_cameras
        save_config(config)
    else:
        config["cameras"] = assigned_cameras
    return config


def save_config(config: Dict[str, Any]) -> None:
    CONFIG_PATH.write_text(json.dumps(config, indent=2))


def assign_ports(cameras: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Ensure each camera has a unique port, auto-assigning if omitted."""

    assigned: List[Dict[str, Any]] = []
    used_ports = {cam.get("port") for cam in cameras if cam.get("port")}
    next_port = DEFAULT_START_PORT

    for cam in cameras:
        cam_copy = dict(cam)
        port = cam_copy.get("port")
        if port is None:
            while next_port in used_ports:
                next_port += 1
            port = next_port
            next_port += 1
        cam_copy["port"] = port
        used_ports.add(port)
        assigned.append(cam_copy)

    return assigned


def generate_nginx_config(config: Dict[str, Any], output_path: Path = NGINX_CONFIG_PATH) -> None:
    """Write an nginx config mapping per-camera ports to the main API."""

    lines = [
        "# Auto-generated by app.py. Include this file from nginx.conf or conf.d.",
        "# Reload nginx after updating the camera configuration.",
        "",
    ]

    for cam in config.get("cameras", []):
        cam_id = cam["id"]
        port = cam["port"]
        lines.extend(
            [
                "server {",
                f"    listen {port};",
                "    location / {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/video;",
                "        proxy_set_header Host $host;",
                "    }",
                "    location /snapshot {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/snapshot;",
                "        proxy_set_header Host $host;",
                "    }",
                "}",
                "",
            ]
        )

    output_path.write_text("\n".join(lines))


###############################################################################
# Models
###############################################################################


class CameraConfig(BaseModel):
    id: str = Field(description="Unique camera identifier")
    name: str
    device: int = Field(description="cv2.VideoCapture device index")
    port: Optional[int] = Field(
        default=None, description="Port for the per-camera proxy (via Nginx)"
    )


class CamerasUpdate(BaseModel):
    host: str = Field(default=DEFAULT_CAMERA_HOST, description="Binding host")
    cameras: List[CameraConfig]


###############################################################################
# App state helpers
###############################################################################


CAMERAS: Dict[str, Camera] = {}
CAMERA_CONFIG: Dict[str, Any] = default_config()


def stop_cameras() -> None:
    for camera in CAMERAS.values():
        camera.stop()
    CAMERAS.clear()


def init_cameras() -> None:
    stop_cameras()

    for cam_cfg in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam_cfg["id"]
        device_index = cam_cfg["device"]

        try:
            camera = Camera(device_index)
        except Exception as exc:  # noqa: BLE001
            print(f"Failed to start camera {cam_id}: {exc}")
            continue

        CAMERAS[cam_id] = camera
        print(f"Started camera {cam_id} on device {device_index}")


###############################################################################
# Shared streaming helpers for the main API
###############################################################################


def mjpeg_generator(cam_id: str):
    if cam_id not in CAMERAS:
        raise HTTPException(status_code=404, detail="Camera not found")

    camera = CAMERAS[cam_id]
    boundary = "frame"
    while True:
        frame = camera.get_frame()
        if frame is None:
            time.sleep(0.1)
            continue

        jpg_bytes = _encode_frame(frame, quality=80)
        if jpg_bytes is None:
            continue

        yield (
            b"--" + boundary.encode() + b"\r\n"
            b"Content-Type: image/jpeg\r\n\r\n" + jpg_bytes + b"\r\n"
        )


def get_snapshot_bytes(cam_id: str) -> bytes:
    if cam_id not in CAMERAS:
        raise HTTPException(status_code=404, detail="Camera not found")
    frame = CAMERAS[cam_id].get_frame()
    if frame is None:
        raise HTTPException(status_code=503, detail="No frame available yet")

    jpg_bytes = _encode_frame(frame, quality=90)
    if jpg_bytes is None:
        raise HTTPException(status_code=500, detail="Failed to encode frame")
    return jpg_bytes


###############################################################################
# API endpoints
###############################################################################


@app.on_event("startup")
def startup_event() -> None:
    global CAMERA_CONFIG
    CAMERA_CONFIG = load_config()
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)


@app.on_event("shutdown")
def shutdown_event() -> None:
    stop_cameras()


@app.get("/", response_class=HTMLResponse)
def index_page():
    cam_list_html = ""
    host = CAMERA_CONFIG.get("host", DEFAULT_CAMERA_HOST)
    for cam in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam["id"]
        port = cam.get("port", "")
        cam_list_html += f"""
        <div style='margin-bottom: 20px;'>
            <h3>{cam_id} - {cam['name']}</h3>
            <div>
                Nginx-mapped endpoints on port {port}:<br>
                <code>http://{host}:{port}/</code> → video<br>
                <code>http://{host}:{port}/snapshot</code> → snapshot
            </div>
            <div style='margin-top: 10px;'>
                Video (main API):<br>
                <img src='/cam/{cam_id}/video' style='max-width: 480px; border: 1px solid #ccc;'>
            </div>
            <div style='margin-top: 10px;'>
                Snapshot (main API):<br>
                <img id='snap-{cam_id}' src='/cam/{cam_id}/snapshot' style='max-width: 320px; border: 1px solid #ccc;'>
            </div>
        </div>
        """

    return f"""
    <html>
    <head>
        <title>Pi Camera Server</title>
        <meta charset="utf-8" />
    </head>
    <body>
        <h1>Pi Camera Server</h1>
        <p>Streams are available both from this API and on per-camera ports.</p>
        {cam_list_html or '<p>No cameras configured. POST to /api/cameras to add one.</p>'}
        <script>
        setInterval(() => {{
            const imgs = document.querySelectorAll("img[id^='snap-']");
            imgs.forEach(img => {{
                const base = img.src.split('?')[0];
                img.src = base + "?t=" + Date.now();
            }});
        }}, 2000);
        </script>
    </body>
    </html>
    """


@app.get("/api/cameras")
def get_cameras():
    return CAMERA_CONFIG


@app.post("/api/cameras")
def set_cameras(data: CamerasUpdate):
    global CAMERA_CONFIG
    camera_dicts = [cam.dict() for cam in data.cameras]
    CAMERA_CONFIG = {"host": data.host, "cameras": assign_ports(camera_dicts)}
    save_config(CAMERA_CONFIG)
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    return {"status": "ok", "cameras": CAMERA_CONFIG}


@app.get("/cam/{cam_id}/video")
def video_stream(cam_id: str):
    return StreamingResponse(
        mjpeg_generator(cam_id),
        media_type="multipart/x-mixed-replace; boundary=frame",
    )


@app.get("/cam/{cam_id}/snapshot")
def snapshot(cam_id: str):
    img_bytes = get_snapshot_bytes(cam_id)
    return Response(content=img_bytes, media_type="image/jpeg")


if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=APP_PORT, reload=False)
