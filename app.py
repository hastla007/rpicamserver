"""
Raspberry Pi camera server exposing MJPEG video and snapshot endpoints per camera.

Run with uvicorn:
    uvicorn app:app --reload --host 0.0.0.0 --port 8000

The main FastAPI app provides configuration APIs and a basic viewer. Per-camera
ports are made available via an autogenerated Nginx configuration mapping to the
central FastAPI endpoints.
"""

import asyncio
import glob
import json
import logging
import os
import secrets
import threading
import time
from logging.handlers import SysLogHandler
from pathlib import Path
from typing import Any, Dict, List, Optional

import cv2
import numpy as np
import uvicorn
from fastapi import Depends, FastAPI, HTTPException
from fastapi.responses import HTMLResponse, Response, StreamingResponse
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from pydantic import BaseModel, Field

CONFIG_PATH = Path("cameras.json")
NGINX_CONFIG_PATH = Path("nginx.cameras.conf")
DEFAULT_CAMERA_HOST = "0.0.0.0"
DEFAULT_START_PORT = 8081
APP_PORT = int(os.getenv("APP_PORT", "8000"))
LOG_DEST = os.getenv("LOG_DEST", "stdout").split(",")
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
LOG_FILE = os.getenv("LOG_FILE")
MAX_DEVICE_PROBE = int(os.getenv("MAX_DEVICE_PROBE", "4"))
PROBE_WHEN_NO_DEVICES = os.getenv("PROBE_WHEN_NO_DEVICES", "false").lower() == "true"
CAMERA_RETRY_INTERVAL = float(os.getenv("CAMERA_RETRY_INTERVAL", "30"))

logger = logging.getLogger("rpicamserver")
security = HTTPBasic(auto_error=False)
CAMERA_STATUS: Dict[str, Dict[str, Any]] = {}


class SafeSysLogHandler(SysLogHandler):
    """Syslog handler that disables itself on emit failures."""

    def emit(self, record):  # type: ignore[override]
        if self.disabled:
            return

        try:
            super().emit(record)
        except OSError as exc:
            self.disabled = True
            self.handleError(record)
            fallback_logger = logging.getLogger("rpicamserver")
            for handler in list(fallback_logger.handlers):
                if handler is self:
                    fallback_logger.removeHandler(self)
            fallback_logger.warning("Disabling syslog handler after emit failure: %s", exc)


def setup_logging() -> None:
    if logger.handlers:
        return

    logger.setLevel(getattr(logging, LOG_LEVEL.upper(), logging.INFO))
    formatter = logging.Formatter(
        "%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    destinations = {dest.strip().lower() for dest in LOG_DEST if dest.strip()}
    if not destinations:
        destinations = {"stdout"}

    if "stdout" in destinations:
        stream_handler = logging.StreamHandler()
        stream_handler.setFormatter(formatter)
        logger.addHandler(stream_handler)

    if "file" in destinations and LOG_FILE:
        file_handler = logging.FileHandler(LOG_FILE)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    if "syslog" in destinations:
        try:
            syslog_handler = SafeSysLogHandler(address="/dev/log")
        except OSError:
            syslog_handler = None

        if syslog_handler:
            syslog_handler.setFormatter(formatter)
            logger.addHandler(syslog_handler)


setup_logging()

app = FastAPI(title="Raspberry Pi Camera Server")


###############################################################################
# Camera capture
###############################################################################


class Camera:
    """Background frame grabber for a single video device."""

    def __init__(
        self,
        cam_id: str,
        device_index: int,
        width: Optional[int] = None,
        height: Optional[int] = None,
        fps: Optional[float] = None,
        brightness: Optional[float] = None,
        exposure: Optional[float] = None,
        white_balance: Optional[float] = None,
    ) -> None:
        self.cam_id = cam_id
        self.device_index = device_index
        self.width = width
        self.height = height
        self.fps = fps
        self.brightness = brightness
        self.exposure = exposure
        self.white_balance = white_balance
        self.capture_interval = 1 / float(fps or 30.0)
        self.idle_wait = 5.0
        self.active_subscribers = 0
        self.subscriber_lock = threading.Lock()
        self.idle_event = threading.Event()
        self.last_frame_ts = 0.0
        self.failure_count = 0
        self.next_retry_ts = time.time()

        try:
            self.cap = self._open_capture()
            CAMERA_STATUS[self.cam_id] = {
                "state": "online",
                "message": "running",
                "device": self.device_index,
            }
        except Exception as exc:  # noqa: BLE001
            self.cap = None
            self.next_retry_ts = time.time() + CAMERA_RETRY_INTERVAL
            CAMERA_STATUS[self.cam_id] = {
                "state": "offline",
                "message": str(exc),
                "device": self.device_index,
            }
            logger.error("Failed to start camera %s: %s", self.cam_id, exc)

        self.frame_lock = threading.Lock()
        self.latest_frame = None
        self.running = True

        self.thread = threading.Thread(target=self._update_loop, daemon=True)
        self.thread.start()

    def _open_capture(self) -> cv2.VideoCapture:
        cap = cv2.VideoCapture(self.device_index)
        if not cap.isOpened():
            cap.release()
            raise RuntimeError(f"Could not open camera device {self.device_index}")

        if self.width:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, int(self.width))
        if self.height:
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, int(self.height))
        if self.fps:
            cap.set(cv2.CAP_PROP_FPS, float(self.fps))
        if self.brightness is not None and hasattr(cv2, "CAP_PROP_BRIGHTNESS"):
            cap.set(getattr(cv2, "CAP_PROP_BRIGHTNESS"), float(self.brightness))
        if self.exposure is not None and hasattr(cv2, "CAP_PROP_EXPOSURE"):
            cap.set(getattr(cv2, "CAP_PROP_EXPOSURE"), float(self.exposure))
        if self.white_balance is not None and hasattr(cv2, "CAP_PROP_WB_TEMPERATURE"):
            cap.set(getattr(cv2, "CAP_PROP_WB_TEMPERATURE"), float(self.white_balance))
        return cap

    def add_subscriber(self) -> None:
        with self.subscriber_lock:
            self.active_subscribers += 1
        self.idle_event.set()

    def remove_subscriber(self) -> None:
        with self.subscriber_lock:
            self.active_subscribers = max(0, self.active_subscribers - 1)
            zero = self.active_subscribers == 0
        if zero:
            self.idle_event.set()

    def request_restart(self) -> None:
        self.next_retry_ts = 0
        self.idle_event.set()

    def _subscriber_count(self) -> int:
        with self.subscriber_lock:
            return self.active_subscribers

    def _restart_capture(self) -> None:
        if time.time() < self.next_retry_ts:
            return

        try:
            if self.cap:
                try:
                    self.cap.release()
                except Exception:  # noqa: BLE001
                    pass

            self.cap = self._open_capture()
            self.failure_count = 0
            self.idle_event.set()
            self.next_retry_ts = time.time()
            CAMERA_STATUS[self.cam_id] = {
                "state": "online",
                "message": "running",
                "device": self.device_index,
            }
            logger.info("Restarted camera device %s", self.device_index)
        except Exception as exc:  # noqa: BLE001
            self.cap = None
            self.next_retry_ts = time.time() + CAMERA_RETRY_INTERVAL
            CAMERA_STATUS[self.cam_id] = {
                "state": "offline",
                "message": str(exc),
                "device": self.device_index,
            }
            logger.error("Failed to restart camera %s: %s", self.device_index, exc)

    def _update_loop(self) -> None:
        while self.running:
            if not self.cap or not self.cap.isOpened():
                if time.time() >= self.next_retry_ts:
                    self._restart_capture()
                time.sleep(0.5)
                continue

            if self._subscriber_count() <= 0:
                self.idle_event.clear()
                self.idle_event.wait(timeout=self.idle_wait)
                # continue to read once to keep snapshots fresh when prompted

            ret, frame = self.cap.read()
            if not ret:
                self.failure_count += 1
                if self.failure_count >= 5:
                    self._restart_capture()
                time.sleep(0.25)
                continue

            self.failure_count = 0
            with self.frame_lock:
                self.latest_frame = frame
                self.last_frame_ts = time.time()
            CAMERA_STATUS[self.cam_id] = {
                "state": "online",
                "message": "running",
                "device": self.device_index,
                "last_frame_ts": self.last_frame_ts,
                "subscribers": self._subscriber_count(),
            }

            time.sleep(self.capture_interval)

    def get_frame(self, wait: bool = False, timeout: float = 1.0):
        if wait:
            self.idle_event.set()
            deadline = time.time() + timeout
            while time.time() < deadline:
                with self.frame_lock:
                    if self.latest_frame is not None:
                        return self.latest_frame.copy()
                time.sleep(0.05)
            return None

        with self.frame_lock:
            if self.latest_frame is None:
                return None
            return self.latest_frame.copy()

    def stop(self) -> None:
        self.running = False
        self.idle_event.set()
        self.thread.join(timeout=1)
        if self.cap:
            self.cap.release()


def _encode_frame(frame, quality: int = 80) -> Optional[bytes]:
    ret, jpeg = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), quality])
    if not ret:
        return None
    return jpeg.tobytes()


def _offline_placeholder(cam_id: str, width: Optional[int] = None, height: Optional[int] = None) -> bytes:
    """Return a small JPEG indicating the camera is offline.

    The placeholder attempts to respect the configured resolution so the aspect ratio
    matches the expected stream size when possible.
    """

    base_width = width or 320
    base_height = height or 240

    if width and not height:
        base_height = max(1, int(width * 3 / 4))
    if height and not width:
        base_width = max(1, int(height * 4 / 3))

    canvas = np.zeros((base_height, base_width, 3), dtype=np.uint8)
    canvas[:] = (28, 35, 52)
    cv2.putText(
        canvas,
        f"{cam_id} offline",
        (20, 120),
        getattr(cv2, "FONT_HERSHEY_SIMPLEX", 0),
        0.7,
        (255, 255, 255),
        2,
        cv2.LINE_AA if hasattr(cv2, "LINE_AA") else 16,
    )
    placeholder = _encode_frame(canvas, quality=85)
    return placeholder or b""


def _configured_resolution(cam_id: str) -> tuple[Optional[int], Optional[int]]:
    cfg = next((c for c in CAMERA_CONFIG.get("cameras", []) if c.get("id") == cam_id), {})
    width = cfg.get("width")
    height = cfg.get("height")

    camera = CAMERAS.get(cam_id)
    if camera:
        width = width or camera.width
        height = height or camera.height

    return width, height


###############################################################################
# Configuration
###############################################################################


def default_config() -> Dict[str, Any]:
    return {
        "host": DEFAULT_CAMERA_HOST,
        "auth": {
            "enabled": False,
            "protect_streams": True,
            "username": "",
            "password": "",
        },
        "cameras": [],
    }


CONTROL_BOUNDS: Dict[str, tuple[float, float]] = {
    "brightness": (0.0, 1.0),
    "exposure": (0.0, 10000.0),
    "white_balance": (0.0, 12000.0),
}


def validate_camera_entries(cameras: List[Dict[str, Any]]) -> None:
    """Validate required camera fields and uniqueness constraints."""

    errors: List[str] = []
    seen_ids: set[str] = set()
    seen_ports: set[int] = set()

    for cam in cameras:
        cam_id = str(cam.get("id", "")).strip()
        name = str(cam.get("name", "")).strip()
        device = cam.get("device")
        port = cam.get("port")
        width = cam.get("width")
        height = cam.get("height")
        fps = cam.get("fps")
        brightness = cam.get("brightness")
        exposure = cam.get("exposure")
        white_balance = cam.get("white_balance")

        if not cam_id:
            errors.append("Camera id is required.")
        elif cam_id in seen_ids:
            errors.append(f"Duplicate camera id '{cam_id}' is not allowed.")
        if not name:
            errors.append(f"Camera '{cam_id or 'unknown'}' must have a name.")
        if device is None or device < 0:
            errors.append(f"Camera '{cam_id or 'unknown'}' requires a non-negative device index.")
        if width is not None and width <= 0:
            errors.append(f"Camera '{cam_id or 'unknown'}' width must be positive when provided.")
        if height is not None and height <= 0:
            errors.append(f"Camera '{cam_id or 'unknown'}' height must be positive when provided.")
        if fps is not None and fps <= 0:
            errors.append(f"Camera '{cam_id or 'unknown'}' fps must be positive when provided.")
        for field_name, value in {
            "brightness": brightness,
            "exposure": exposure,
            "white_balance": white_balance,
        }.items():
            if value is not None and value != "":
                try:
                    numeric = float(value)
                except (TypeError, ValueError):
                    errors.append(
                        f"Camera '{cam_id or 'unknown'}' {field_name} must be numeric when provided."
                    )
                    continue

                min_val, max_val = CONTROL_BOUNDS[field_name]
                if numeric < min_val or numeric > max_val:
                    errors.append(
                        f"Camera '{cam_id or 'unknown'}' {field_name} should be between {min_val} and {max_val}."
                    )
        if port is not None:
            if port <= 0:
                errors.append(f"Camera '{cam_id or 'unknown'}' has an invalid port: {port}.")
            if port in seen_ports:
                errors.append(
                    f"Duplicate port {port} is not allowed; leave blank for auto-assignment."
                )
            seen_ports.add(port)

        seen_ids.add(cam_id)

    if errors:
        raise ValueError("; ".join(errors))


def validate_auth(auth_cfg: Dict[str, Any]) -> None:
    if not auth_cfg:
        return

    enabled = bool(auth_cfg.get("enabled"))
    username = str(auth_cfg.get("username", "")).strip()
    password = str(auth_cfg.get("password", "")).strip()

    if enabled and (not username or not password):
        raise ValueError("Auth is enabled but username or password is missing.")


def load_config() -> Dict[str, Any]:
    if CONFIG_PATH.exists():
        config = json.loads(CONFIG_PATH.read_text())
    else:
        config = default_config()

    if "auth" not in config:
        config["auth"] = default_config()["auth"].copy()
    else:
        auth_cfg = config.get("auth", {})
        if auth_cfg.get("enabled") and "protect_streams" not in auth_cfg:
            auth_cfg["protect_streams"] = True
        else:
            auth_cfg.setdefault("protect_streams", False)
        config["auth"] = auth_cfg

    assigned_cameras = assign_ports(config.get("cameras", []))
    try:
        validate_auth(config.get("auth", {}))
        config.pop("auth_error", None)
    except ValueError as exc:  # noqa: BLE001
        config["auth_error"] = str(exc)
        logger.error("Invalid auth configuration: %s", exc)
    try:
        validate_camera_entries(assigned_cameras)
    except ValueError as exc:  # noqa: BLE001
        logger.warning("Invalid camera configuration: %s. Resetting to defaults.", exc)
        config = default_config()
        assigned_cameras = []

    if assigned_cameras != config.get("cameras", []):
        config["cameras"] = assigned_cameras
        save_config(config)
    else:
        config["cameras"] = assigned_cameras
    return config


def save_config(config: Dict[str, Any]) -> None:
    CONFIG_PATH.write_text(json.dumps(config, indent=2))


def assign_ports(cameras: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Ensure each camera has a unique port, auto-assigning if omitted or duplicated."""

    assigned: List[Dict[str, Any]] = []
    used_ports: set[int] = set()
    next_port = DEFAULT_START_PORT

    for cam in cameras:
        cam_copy = dict(cam)
        port = cam_copy.get("port")

        if port is not None:
            # Keep user-provided ports when available and unused.
            if port in used_ports:
                next_port = max(next_port, port + 1)
                port = None
            else:
                used_ports.add(port)
                next_port = max(next_port, port + 1)

        if port is None:
            while next_port in used_ports:
                next_port += 1
            port = next_port
            used_ports.add(port)
            next_port += 1

        cam_copy["port"] = port
        assigned.append(cam_copy)

    return assigned


def discover_cameras(
    max_devices: Optional[int] = None, probe_when_empty: Optional[bool] = None
) -> List[Dict[str, Any]]:
    """Probe video capture devices and return detected indices and metadata."""

    discovered: List[Dict[str, Any]] = []
    used_devices = {cam.get("device") for cam in CAMERA_CONFIG.get("cameras", [])}
    existing_nodes = sorted(
        {
            int(Path(dev).name.replace("video", ""))
            for dev in glob.glob("/dev/video*")
            if Path(dev).name.replace("video", "").isdigit()
        }
    )
    probe_limit = max_devices if max_devices is not None else MAX_DEVICE_PROBE
    should_probe_missing = (
        probe_when_empty
        if probe_when_empty is not None
        else PROBE_WHEN_NO_DEVICES
    )

    if existing_nodes:
        probe_indices = existing_nodes
    elif should_probe_missing and probe_limit > 0:
        probe_indices = list(range(probe_limit))
    else:
        return []

    for idx in probe_indices:
        cap = cv2.VideoCapture(idx)
        if not cap.isOpened():
            cap.release()
            continue

        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH) or 0)
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT) or 0)
        fps = float(cap.get(cv2.CAP_PROP_FPS) or 0.0)
        brightness = (
            float(cap.get(cv2.CAP_PROP_BRIGHTNESS))
            if hasattr(cv2, "CAP_PROP_BRIGHTNESS")
            else None
        )
        exposure = (
            float(cap.get(cv2.CAP_PROP_EXPOSURE))
            if hasattr(cv2, "CAP_PROP_EXPOSURE")
            else None
        )
        white_balance = (
            float(cap.get(cv2.CAP_PROP_WB_TEMPERATURE))
            if hasattr(cv2, "CAP_PROP_WB_TEMPERATURE")
            else None
        )
        cap.release()

        discovered.append(
            {
                "index": idx,
                "in_use": idx in used_devices,
                "resolution": {
                    "width": width or None,
                    "height": height or None,
                },
                "fps": fps or None,
                "controls": {
                    "brightness": brightness if brightness is not None else None,
                    "exposure": exposure if exposure is not None else None,
                    "white_balance": white_balance if white_balance is not None else None,
                },
            }
        )

    return discovered


def generate_nginx_config(config: Dict[str, Any], output_path: Path = NGINX_CONFIG_PATH) -> None:
    """Write an nginx config mapping per-camera ports to the main API."""

    lines = [
        "# Auto-generated by app.py. Include this file from nginx.conf or conf.d.",
        "# Reload nginx after updating the camera configuration.",
        "",
    ]

    for cam in config.get("cameras", []):
        cam_id = cam["id"]
        port = cam["port"]
        lines.extend(
            [
                "server {",
                f"    listen {port};",
                "    location / {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/video;",
                "        proxy_set_header Host $host;",
                "    }",
                "    location /snapshot {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/snapshot;",
                "        proxy_set_header Host $host;",
                "    }",
                "}",
                "",
            ]
        )

    output_path.write_text("\n".join(lines))


###############################################################################
# Models
###############################################################################


class CameraConfig(BaseModel):
    id: str = Field(description="Unique camera identifier")
    name: str
    device: int = Field(description="cv2.VideoCapture device index")
    port: Optional[int] = Field(
        default=None, description="Port for the per-camera proxy (via Nginx)"
    )
    width: Optional[int] = Field(default=None, description="Capture width")
    height: Optional[int] = Field(default=None, description="Capture height")
    fps: Optional[float] = Field(default=None, description="Requested FPS")
    brightness: Optional[float] = Field(default=None, description="Brightness level")
    exposure: Optional[float] = Field(default=None, description="Exposure level")
    white_balance: Optional[float] = Field(
        default=None, description="White balance temperature"
    )


class AuthConfig(BaseModel):
    enabled: bool = Field(default=False, description="Enable HTTP basic auth")
    protect_streams: bool = Field(
        default=True, description="Apply auth to /cam/* streams as well"
    )
    username: str = Field(default="", description="Basic auth username")
    password: str = Field(default="", description="Basic auth password")


class CamerasUpdate(BaseModel):
    host: str = Field(default=DEFAULT_CAMERA_HOST, description="Binding host")
    cameras: List[CameraConfig]
    auth: AuthConfig = Field(default_factory=AuthConfig)


###############################################################################
# App state helpers
###############################################################################


CAMERAS: Dict[str, Optional[Camera]] = {}
CAMERA_CONFIG: Dict[str, Any] = default_config()


def _auth_enabled() -> bool:
    auth_cfg = CAMERA_CONFIG.get("auth", {})
    return bool(
        auth_cfg
        and auth_cfg.get("enabled")
        and auth_cfg.get("username")
        and auth_cfg.get("password")
    )


def require_auth(credentials: Optional[HTTPBasicCredentials] = Depends(security)) -> None:
    if CAMERA_CONFIG.get("auth_error"):
        raise HTTPException(
            status_code=500,
            detail=f"Auth configuration error: {CAMERA_CONFIG['auth_error']}",
        )

    if not _auth_enabled():
        return

    if not credentials or not credentials.username:
        raise HTTPException(
            status_code=401,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Basic"},
        )

    expected_user = CAMERA_CONFIG.get("auth", {}).get("username", "")
    expected_pass = CAMERA_CONFIG.get("auth", {}).get("password", "")

    if not (
        secrets.compare_digest(credentials.username, expected_user)
        and secrets.compare_digest(credentials.password or "", expected_pass)
    ):
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Basic"},
        )


def require_stream_auth(
    credentials: Optional[HTTPBasicCredentials] = Depends(security),
) -> None:
    auth_cfg = CAMERA_CONFIG.get("auth", {})
    if not auth_cfg.get("protect_streams"):
        return
    require_auth(credentials)


def stop_cameras() -> None:
    for camera in CAMERAS.values():
        if camera:
            camera.stop()
    CAMERAS.clear()
    CAMERA_STATUS.clear()


def restart_camera(cam_id: str) -> Dict[str, Any]:
    cam_cfg = next((c for c in CAMERA_CONFIG.get("cameras", []) if c.get("id") == cam_id), None)
    if not cam_cfg:
        raise HTTPException(status_code=404, detail="Camera not configured")

    camera = CAMERAS.get(cam_id)
    if camera:
        camera.request_restart()
        return {"status": "restarting"}

    # Attempt to create a new camera instance if the previous one failed to open
    try:
        new_cam = Camera(
            cam_id,
            cam_cfg["device"],
            width=cam_cfg.get("width"),
            height=cam_cfg.get("height"),
            fps=cam_cfg.get("fps"),
            brightness=cam_cfg.get("brightness"),
            exposure=cam_cfg.get("exposure"),
            white_balance=cam_cfg.get("white_balance"),
        )
        CAMERAS[cam_id] = new_cam
        return {"status": "restarted"}
    except Exception as exc:  # noqa: BLE001
        logger.error("Manual restart failed for %s: %s", cam_id, exc)
        CAMERA_STATUS[cam_id] = {
            "state": "offline",
            "message": str(exc),
            "device": cam_cfg.get("device"),
        }
        CAMERAS[cam_id] = None  # type: ignore[assignment]
        raise HTTPException(status_code=503, detail=f"Restart failed: {exc}")


def init_cameras() -> None:
    stop_cameras()

    for cam_cfg in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam_cfg["id"]
        device_index = cam_cfg["device"]
        width = cam_cfg.get("width")
        height = cam_cfg.get("height")
        fps = cam_cfg.get("fps")
        brightness = cam_cfg.get("brightness")
        exposure = cam_cfg.get("exposure")
        white_balance = cam_cfg.get("white_balance")

        try:
            camera = Camera(
                cam_id,
                device_index,
                width=width,
                height=height,
                fps=fps,
                brightness=brightness,
                exposure=exposure,
                white_balance=white_balance,
            )
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to initialize camera %s: %s", cam_id, exc)
            CAMERA_STATUS[cam_id] = {
                "state": "offline",
                "message": str(exc),
                "device": device_index,
            }
            # Create a stub entry so placeholders continue to work even when init fails
            camera = None

        if camera:
            CAMERAS[cam_id] = camera
            logger.info("Started camera %s on device %s", cam_id, device_index)
        else:
            CAMERAS[cam_id] = None  # type: ignore[assignment]


###############################################################################
# Shared streaming helpers for the main API
###############################################################################


async def mjpeg_generator(cam_id: str):
    config_exists = any(c.get("id") == cam_id for c in CAMERA_CONFIG.get("cameras", []))
    camera = CAMERAS.get(cam_id)
    boundary = "frame"

    if camera is None and not config_exists:
        raise HTTPException(status_code=404, detail="Camera not found")

    if camera:
        camera.add_subscriber()

    try:
        while True:
            if camera:
                frame = await asyncio.to_thread(camera.get_frame, True, 1.0)
                if frame is None:
                    width, height = _configured_resolution(cam_id)
                    jpg_bytes = _offline_placeholder(cam_id, width, height)
                    sleep_interval = 1.0
                else:
                    jpg_bytes = _encode_frame(frame, quality=80)
                    if jpg_bytes is None:
                        await asyncio.sleep(camera.capture_interval)
                        continue
                    sleep_interval = camera.capture_interval
            else:
                width, height = _configured_resolution(cam_id)
                jpg_bytes = _offline_placeholder(cam_id, width, height)
                sleep_interval = 1.0

            yield (
                b"--" + boundary.encode() + b"\r\n"
                b"Content-Type: image/jpeg\r\n\r\n" + jpg_bytes + b"\r\n"
            )
            await asyncio.sleep(sleep_interval)
    finally:
        if camera:
            camera.remove_subscriber()


def get_snapshot_bytes(cam_id: str) -> bytes:
    camera = CAMERAS.get(cam_id)
    config_exists = any(c.get("id") == cam_id for c in CAMERA_CONFIG.get("cameras", []))

    if not camera and not config_exists:
        raise HTTPException(status_code=404, detail="Camera not found")

    if not camera:
        target_width, target_height = _configured_resolution(cam_id)
        return _offline_placeholder(cam_id, width=target_width, height=target_height)

    frame = camera.get_frame(wait=True, timeout=1.5)
    if frame is None:
        logger.warning("No frame available for %s; returning placeholder.", cam_id)
        target_width, target_height = _configured_resolution(cam_id)
        return _offline_placeholder(cam_id, width=target_width, height=target_height)

    jpg_bytes = _encode_frame(frame, quality=90)
    if jpg_bytes is None:
        target_width, target_height = _configured_resolution(cam_id)
        placeholder = _offline_placeholder(cam_id, width=target_width, height=target_height)
        if placeholder:
            return placeholder
        raise HTTPException(status_code=500, detail="Failed to encode frame")
    return jpg_bytes


def camera_statuses() -> List[Dict[str, Any]]:
    now = time.time()
    configs = {cam.get("id"): cam for cam in CAMERA_CONFIG.get("cameras", [])}
    statuses: List[Dict[str, Any]] = []

    for cam_id, cfg in configs.items():
        status = {
            "id": cam_id,
            "state": "offline",
            "message": "not started",
            "device": cfg.get("device"),
            "port": cfg.get("port"),
            "last_frame_age": None,
            "last_frame_ts": None,
            "subscribers": 0,
        }

        if cam_id in CAMERA_STATUS:
            status.update(CAMERA_STATUS[cam_id])

        camera = CAMERAS.get(cam_id)
        if camera:
            status["subscribers"] = camera._subscriber_count()
            if camera.last_frame_ts:
                age = now - camera.last_frame_ts
                status["last_frame_age"] = age
                status["last_frame_ts"] = camera.last_frame_ts
                if age > 5 and status.get("state") == "online":
                    status["state"] = "stale"
                    status["message"] = "no recent frames"

        statuses.append(status)

    return statuses


###############################################################################
# API endpoints
###############################################################################


@app.on_event("startup")
def startup_event() -> None:
    global CAMERA_CONFIG
    CAMERA_CONFIG = load_config()
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    logger.info("Camera server started with %d configured camera(s)", len(CAMERA_CONFIG.get("cameras", [])))


@app.on_event("shutdown")
def shutdown_event() -> None:
    logger.info("Shutting down camera server")
    stop_cameras()


def _base_page(title: str, active: str, body: str) -> str:
    nav_items = {
        "home": ("/", "Cameras"),
        "settings": ("/settings", "Settings"),
        "docs": ("/api-docs", "API Docs"),
    }

    nav_html = "".join(
        f"<a class='{'nav-link active' if key == active else 'nav-link'}' href='{href}'>"
        f"{label}</a>" for key, (href, label) in nav_items.items()
    )

    template = """
    <html>
    <head>
        <title>__TITLE__</title>
        <meta charset=\"utf-8\" />
        <style>
            :root {
                color-scheme: light dark;
                --bg: #0f172a;
                --panel: #111827;
                --accent: #3b82f6;
                --text: #e5e7eb;
                --muted: #94a3b8;
                --border: #1f2937;
                font-family: 'Inter', system-ui, -apple-system, sans-serif;
            }
            body {
                margin: 0 auto;
                max-width: 1100px;
                padding: 24px 16px 48px;
                color: var(--text);
                background: linear-gradient(180deg, #0b1224 0%, #0f172a 35%, #0f172a 100%);
            }
            h1 { margin: 0 0 16px; letter-spacing: -0.02em; }
            p { color: var(--muted); }
            .nav {
                display: flex;
                gap: 12px;
                margin: 16px 0 24px;
                border-bottom: 1px solid var(--border);
                padding-bottom: 10px;
            }
            .nav-link {
                color: var(--muted);
                text-decoration: none;
                padding: 8px 12px;
                border-radius: 8px;
                transition: background 0.15s, color 0.15s;
            }
            .nav-link:hover { color: var(--text); background: #111827; }
            .nav-link.active {
                background: rgba(59, 130, 246, 0.15);
                color: #bfdbfe;
                border: 1px solid rgba(59, 130, 246, 0.4);
            }
            .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
            .card {
                background: var(--panel);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.25);
            }
            .pill {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                background: rgba(59, 130, 246, 0.1);
                color: #bfdbfe;
                padding: 6px 10px;
                border-radius: 999px;
                font-size: 12px;
                border: 1px solid rgba(59,130,246,0.25);
            }
            code { background: rgba(255,255,255,0.04); padding: 2px 4px; border-radius: 6px; }
            .btn {
                background: var(--accent);
                color: white;
                padding: 10px 14px;
                border-radius: 10px;
                border: none;
                cursor: pointer;
                font-weight: 600;
                box-shadow: 0 10px 30px rgba(59,130,246,0.25);
            }
            .btn-secondary {
                background: #1f2937;
                color: var(--text);
                border: 1px solid var(--border);
            }
            .input, select {
                width: 100%;
                padding: 10px 12px;
                border-radius: 10px;
                border: 1px solid var(--border);
                background: #0b1224;
                color: var(--text);
            }
            table { width: 100%; border-collapse: collapse; margin-top: 12px; }
            th, td { text-align: left; padding: 8px; border-bottom: 1px solid var(--border); }
            .muted { color: var(--muted); font-size: 14px; }
            .status { margin-top: 12px; font-weight: 600; }
            .status.error { color: #fca5a5; }
            .status.success { color: #a7f3d0; }
            a { color: #93c5fd; }
            .pill.offline { background: rgba(248,113,113,0.1); color: #fecaca; border-color: rgba(248,113,113,0.35); }
            .pill.stale { background: rgba(251,191,36,0.1); color: #fcd34d; border-color: rgba(251,191,36,0.35); }
        </style>
    </head>
    <body>
        <h1>Pi Camera Server</h1>
        <div class=\"nav\">__NAV__</div>
        __BODY__
    </body>
    </html>
    """

    return (
        template.replace("__NAV__", nav_html)
        .replace("__BODY__", body)
        .replace("__TITLE__", title)
    )


@app.get("/", response_class=HTMLResponse)
def index_page():
    host = CAMERA_CONFIG.get("host", DEFAULT_CAMERA_HOST)
    cards = []
    for cam in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam["id"]
        port = cam.get("port")
        name = cam.get("name", cam_id)
        width = cam.get("width")
        height = cam.get("height")
        fps = cam.get("fps")
        res_text = (
            f"{width}√ó{height}"
            if width and height
            else "Default resolution"
        )
        if fps:
            res_text += f" @ {fps} fps"
        cards.append(
            f"""
            <div class='card'>
                <div style='display:flex; justify-content: space-between; align-items:center;'>
                    <div>
                        <div class='pill'>üé• Camera ¬∑ {cam_id}</div>
                        <h3 style='margin:8px 0 4px;'>{name}</h3>
                        <p class='muted'>Device index: {cam['device']}</p>
                        <p class='muted'>Capture: {res_text}</p>
                        <div style='display:flex; gap:8px; align-items:center; flex-wrap:wrap;'>
                            <div class='pill status-pill muted' data-cam='{cam_id}' aria-live='polite'>Status: checking‚Ä¶</div>
                            <button class='btn-secondary btn' style='padding:6px 10px; box-shadow:none;' onclick="retryCamera('{cam_id}')">Retry</button>
                        </div>
                    </div>
                    <div style='text-align:right;'>
                        <div class='muted'>Port</div>
                        <div style='font-weight:700;'>:{port}</div>
                    </div>
                </div>
                <div style='margin:12px 0;'>
                    <img src='/cam/{cam_id}/video' style='width:100%; border:1px solid var(--border); border-radius:10px;'>
                </div>
                <div style='display:flex; gap:12px; align-items:center; flex-wrap:wrap;'>
                    <img id='snap-{cam_id}' src='/cam/{cam_id}/snapshot' style='width:140px; border:1px solid var(--border); border-radius:8px;'>
                    <div>
                        <div class='muted'>Main API</div>
                        <code>/cam/{cam_id}/video</code><br>
                        <code>/cam/{cam_id}/snapshot</code>
                        <div style='margin-top:6px;' class='muted'>Nginx mapped:</div>
                        <code>http://{host}:{port}/</code><br>
                        <code>http://{host}:{port}/snapshot</code>
                    </div>
                </div>
            </div>
            """
        )

    body = f"""
        <p class='muted'>Streams are available via the main API and per-camera ports generated in nginx.cameras.conf.</p>
        <div class='card-grid'>
            {''.join(cards) if cards else '<div class="card"><p>No cameras configured yet. Add one in Settings.</p></div>'}
        </div>
        <script>
            async function retryCamera(camId) {{
                try {{
                    const res = await fetch(`/api/cameras/${{camId}}/restart`, {{ method: 'POST' }});
                    if (!res.ok) {{
                        const err = await res.text();
                        throw new Error(err || 'Restart failed');
                    }}
                }} catch (err) {{
                    console.error('Retry failed', err);
                    alert('Retry failed: ' + err);
                }}
            }}

            setInterval(() => {{
                const imgs = document.querySelectorAll("img[id^='snap-']");
                imgs.forEach(img => {{
                    const base = img.src.split('?')[0];
                    img.src = base + "?t=" + Date.now();
                }});
            }}, 2000);

            async function refreshHealth() {{
                try {{
                    const res = await fetch('/health');
                    const data = await res.json();
                    (data.cameras || []).forEach(cam => {{
                        const pill = document.querySelector(`.status-pill[data-cam="${{cam.id}}"]`);
                        if (!pill) return;
                        pill.classList.remove('offline', 'stale', 'muted');
                        if (cam.state === 'offline') pill.classList.add('offline');
                        else if (cam.state === 'stale') pill.classList.add('stale');
                        pill.textContent = `Status: ${{cam.state}}${{cam.message ? ' ¬∑ ' + cam.message : ''}}`;
                    }});
                }} catch (err) {{
                    console.warn('Health check failed', err);
                }}
            }}

            refreshHealth();
            setInterval(refreshHealth, 5000);
        </script>
    """

    return _base_page("Pi Camera Server", "home", body)


@app.get("/settings", response_class=HTMLResponse, dependencies=[Depends(require_auth)])
def settings_page():
    body = """
        <div class='card'>
            <div style='display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;'>
                <div>
                    <div class='pill'>‚öôÔ∏è Setup</div>
                    <h2 style='margin:8px 0 4px;'>Camera configuration</h2>
                    <p class='muted'>Edit the host and cameras, then save to regenerate nginx.cameras.conf and restart capture threads.</p>
                </div>
                <button class='btn' onclick='saveConfig()'>üíæ Save changes</button>
            </div>
            <div style='margin-top:16px;'>
                <label class='muted'>Binding host</label>
                <input class='input' id='host' placeholder='0.0.0.0'>
            </div>
            <div style='margin-top:16px; display:flex; flex-direction:column; gap:6px;'>
                <div style='display:flex; gap:12px; flex-wrap:wrap; align-items:center;'>
                    <label class='muted'>Authentication (optional)</label>
                    <label style='display:flex; gap:6px; align-items:center;'><input type='checkbox' id='auth-enabled'> Require basic auth for settings/API</label>
                    <label style='display:flex; gap:6px; align-items:center;'><input type='checkbox' id='auth-streams'> Protect streams too</label>
                </div>
                <div style='display:flex; gap:10px; flex-wrap:wrap;'>
                    <input class='input' id='auth-username' placeholder='admin' style='max-width:160px;'>
                    <input class='input' id='auth-password' type='password' placeholder='password' style='max-width:180px;'>
                </div>
                <p class='muted' style='margin:0;'>If enabled, browsers will prompt for these credentials on configuration endpoints (and streams if selected).</p>
            </div>
            <div style='margin-top:16px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;'>
                <div>
                    <h3 style='margin:0;'>Cameras</h3>
                    <p class='muted' style='margin:4px 0 0;'>Pick from unused devices when adding a new entry.</p>
                </div>
                <div style='display:flex; gap:8px; flex-wrap:wrap;'>
                    <button class='btn-secondary btn' onclick='refreshDevices()'>‚Üª Rescan devices</button>
                    <button class='btn-secondary btn' onclick='addRow()'>Ôºã Add camera</button>
                </div>
            </div>
            <div style='margin:10px 0; display:flex; gap:12px; align-items:center; flex-wrap:wrap;'>
                <label style='display:flex; gap:6px; align-items:center;'><input type='checkbox' id='probe-missing'> Probe missing indices when no /dev/video* entries</label>
                <label class='muted' style='display:flex; gap:6px; align-items:center;'>Max probe <input class='input' id='probe-limit' type='number' min='0' style='width:80px;'></label>
                <p class='muted' style='margin:0;'>Leave unchecked to avoid probing in headless/virtual environments.</p>
            </div>
            <div id='device-list' style='margin:10px 0 12px;'></div>
            <div style='overflow-x:auto;'>
                <table id='cam-table'>
                    <thead>
                        <tr><th>ID</th><th>Name</th><th>Device</th><th>Port</th><th>Width</th><th>Height</th><th>FPS</th><th>Brightness</th><th>Exposure</th><th>WB Temp</th><th></th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <p class='muted' style='margin:10px 0 0;'>Brightness 0.0‚Äì1.0 ¬∑ Exposure 0‚Äì10,000 ¬∑ White balance 0‚Äì12,000 (Kelvin). Leave blank for camera defaults.</p>
            <div id='status' class='status muted'></div>
        </div>
        <script>
            const tbody = document.querySelector('#cam-table tbody');
            const status = document.getElementById('status');
            const authEnabled = document.getElementById('auth-enabled');
            const authStreams = document.getElementById('auth-streams');
            const authUser = document.getElementById('auth-username');
            const authPass = document.getElementById('auth-password');
            const probeMissingEl = document.getElementById('probe-missing');
            const probeLimitEl = document.getElementById('probe-limit');
            let devices = [];

            const defaultProbeMissing = __PROBE_MISSING__;
            const defaultProbeLimit = __PROBE_LIMIT__;
            probeMissingEl.checked = defaultProbeMissing;
            probeLimitEl.value = defaultProbeLimit;

            function setStatus(text, variant='muted') {
                status.textContent = text;
                status.classList.remove('error', 'success', 'muted');
                status.classList.add(variant);
            }

            function buildAuthHeaders() {
                if (!authEnabled.checked) return {};
                const user = authUser.value.trim();
                const pass = authPass.value;
                if (!user || !pass) return {};
                return { 'Authorization': 'Basic ' + btoa(`${user}:${pass}`) };
            }

            function currentProbeParams() {
                const maxVal = Number(probeLimitEl.value);
                const limit = Number.isFinite(maxVal) && maxVal > 0 ? maxVal : defaultProbeLimit;
                return { max: limit, probe_missing: probeMissingEl.checked };
            }

            function renderDeviceOptions(currentDevice) {
                if (!devices.length) {
                    const val = currentDevice ?? '';
                    return `<option value="${val}">${val === '' ? 'Enter a device number' : 'Device ' + val}</option>`;
                }

                const options = devices.map(dev => {
                    const disabled = dev.in_use && dev.index !== currentDevice;
                    const res = (dev.resolution?.width && dev.resolution?.height)
                        ? `${dev.resolution.width}√ó${dev.resolution.height}`
                        : 'resolution unknown';
                    const fpsText = dev.fps ? ` ¬∑ ${dev.fps.toFixed(1)} fps` : '';
                    return `<option value="${dev.index}" ${dev.index === currentDevice ? 'selected' : ''} ${disabled ? 'disabled' : ''}>${dev.index} ¬∑ ${res}${fpsText}${dev.in_use && dev.index !== currentDevice ? ' (in use)' : ''}</option>`;
                }).join('');

                const fallback = (currentDevice !== null && currentDevice !== '' && !devices.some(d => d.index === currentDevice))
                    ? `<option value="${currentDevice}" selected>Device ${currentDevice}</option>`
                    : '';

                return `<option value="">Select device‚Ä¶</option>${options}${fallback}`;
            }

            function updateDeviceSelects() {
                const selects = tbody.querySelectorAll('select.device-select');
                selects.forEach(sel => {
                    const currentVal = sel.value === '' ? '' : Number(sel.value);
                    sel.innerHTML = renderDeviceOptions(Number.isNaN(currentVal) ? '' : currentVal);
                    sel.value = sel.dataset.current = sel.value || (Number.isNaN(currentVal) ? '' : currentVal);
                });
            }

            function addRow(cam={id:'', name:'', device:'', port:'', width:'', height:'', fps:'', brightness:'', exposure:'', white_balance:''}) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input class='input' value='${cam.id}' placeholder='cam1'></td>
                    <td><input class='input' value='${cam.name}' placeholder='USB Cam'></td>
                    <td><select class='input device-select' data-current='${cam.device ?? ''}'></select></td>
                    <td><input class='input' value='${cam.port ?? ''}' type='number' min='0' style='width:100px'></td>
                    <td><input class='input' value='${cam.width ?? ''}' type='number' min='0' style='width:100px' placeholder='auto'></td>
                    <td><input class='input' value='${cam.height ?? ''}' type='number' min='0' style='width:100px' placeholder='auto'></td>
                    <td><input class='input' value='${cam.fps ?? ''}' type='number' min='0' step='0.1' style='width:100px' placeholder='auto'></td>
                    <td><input class='input' value='${cam.brightness ?? ''}' type='number' step='0.1' min='0' max='1' style='width:120px' placeholder='0.0‚Äì1.0' title='Brightness range 0.0‚Äì1.0; blank uses camera default'></td>
                    <td><input class='input' value='${cam.exposure ?? ''}' type='number' step='0.1' min='0' max='10000' style='width:120px' placeholder='0‚Äì10000' title='Exposure range 0‚Äì10,000 (device units); blank uses camera default'></td>
                    <td><input class='input' value='${cam.white_balance ?? ''}' type='number' step='1' min='0' max='12000' style='width:120px' placeholder='0‚Äì12000' title='White balance range 0‚Äì12,000 (Kelvin if supported); blank uses camera default'></td>
                    <td style='width:60px; text-align:right;'><button class='btn-secondary btn' onclick='this.closest("tr").remove(); updateDeviceSelects();'>‚úñ</button></td>
                `;
                tbody.appendChild(tr);
                updateDeviceSelects();
            }

            async function loadConfig() {
                try {
                    const res = await fetch('/api/cameras', { headers: buildAuthHeaders() });
                    const data = await res.json();
                    document.querySelector('#host').value = data.host || '';
                    const authCfg = data.auth || {};
                    authEnabled.checked = !!authCfg.enabled;
                    authStreams.checked = !!authCfg.protect_streams;
                    authUser.value = authCfg.username || '';
                    authPass.value = authCfg.password || '';
                    tbody.innerHTML = '';
                    (data.cameras || []).forEach(addRow);
                    await refreshDevices(defaultProbeMissing, true);
                    setStatus('Loaded configuration.');
                } catch (err) {
                    setStatus('Failed to load configuration: ' + err, 'error');
                }
            }

            async function refreshDevices(showStatus=true, allowSkip=false) {
                if (allowSkip && !probeMissingEl.checked && !devices.length) {
                    renderDeviceList();
                    updateDeviceSelects();
                    if (showStatus) setStatus('Discovery skipped. Enable probing to scan indices.', 'muted');
                    return;
                }
                if (showStatus) setStatus('Scanning for connected cameras‚Ä¶');
                try {
                    const params = new URLSearchParams(currentProbeParams());
                    const res = await fetch('/api/devices?' + params.toString(), { headers: buildAuthHeaders() });
                    const data = await res.json();
                    devices = data.devices || [];
                    renderDeviceList();
                    updateDeviceSelects();
                    if (showStatus) setStatus('Camera scan complete.');
                } catch (err) {
                    if (showStatus) setStatus('Failed to scan devices: ' + err, 'error');
                }
            }

            function renderDeviceList() {
                const container = document.getElementById('device-list');
                if (!devices.length) {
                    container.innerHTML = '<p class="muted">No cameras detected. You can still enter a device number manually.</p>';
                    return;
                }

                const rows = devices.map(dev => {
                    const res = (dev.resolution?.width && dev.resolution?.height)
                        ? `${dev.resolution.width}√ó${dev.resolution.height}`
                        : 'unknown';
                    const fps = dev.fps ? `${dev.fps.toFixed(1)} fps` : 'unknown';
                    const ctrl = dev.controls || {};
                    const controls = ['brightness', 'exposure', 'white_balance']
                        .map(key => ctrl[key] !== null && ctrl[key] !== undefined ? `${key}: ${ctrl[key].toFixed ? ctrl[key].toFixed(1) : ctrl[key]}` : null)
                        .filter(Boolean)
                        .join(' ¬∑ ');
                    const dim = dev.in_use ? 'style="opacity:0.45;"' : '';
                    const action = dev.in_use
                        ? '<span class="pill" style="background:rgba(148,163,184,0.15); color:#cbd5e1; border-color:rgba(148,163,184,0.35);">In use</span>'
                        : `<button class='btn-secondary btn' onclick='addFromDevice(${dev.index})'>Add</button>`;
                    return `<tr ${dim}><td>${dev.index}</td><td>${res}</td><td>${fps}</td><td>${controls || 'n/a'}</td><td>${action}</td></tr>`;
                }).join('');

                container.innerHTML = `<table><thead><tr><th>Device</th><th>Resolution</th><th>FPS</th><th>Controls</th><th></th></tr></thead><tbody>${rows}</tbody></table>`;
            }

            function addFromDevice(index) {
                const existing = Array.from(tbody.querySelectorAll('tr')).some(row => {
                    const deviceVal = row.querySelector('select.device-select')?.value;
                    return deviceVal !== '' && Number(deviceVal) === index;
                });
                if (existing) return;
                const dev = devices.find(d => d.index === index) || {};
                addRow({ id: `cam${index}`, name: `Camera ${index}`, device: index, port: '', width: dev.resolution?.width || '', height: dev.resolution?.height || '', fps: dev.fps || '', brightness: dev.controls?.brightness ?? '', exposure: dev.controls?.exposure ?? '', white_balance: dev.controls?.white_balance ?? '' });
                setStatus(`Added device ${index} to the table.`);
            }

            async function saveConfig() {
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const errors = [];
                const seenIds = new Set();
                const seenPorts = new Set();
                const authCfg = {
                    enabled: authEnabled.checked,
                    protect_streams: authStreams.checked && authEnabled.checked,
                    username: authUser.value.trim(),
                    password: authPass.value,
                };

                if (authCfg.enabled && (!authCfg.username || !authCfg.password)) {
                    errors.push('Auth is enabled but username/password are missing.');
                }

                const cameras = rows.map(r => {
                    const inputs = Array.from(r.querySelectorAll('input'));
                    const [id,name,port,width,height,fps,brightness,exposure,whiteBalance] = inputs.map(i => i.value.trim());
                    const deviceSelect = r.querySelector('select');
                    const device = deviceSelect ? deviceSelect.value.trim() : '';
                    const deviceNum = device === '' ? NaN : Number(device);
                    const portNum = port === '' ? null : Number(port);
                    const widthNum = width === '' ? null : Number(width);
                    const heightNum = height === '' ? null : Number(height);
                    const fpsNum = fps === '' ? null : Number(fps);
                    const brightnessNum = brightness === '' ? null : Number(brightness);
                    const exposureNum = exposure === '' ? null : Number(exposure);
                    const whiteBalanceNum = whiteBalance === '' ? null : Number(whiteBalance);

                    if (!id) errors.push('Camera ID is required.');
                    if (id && seenIds.has(id)) errors.push(`Duplicate camera id "${id}".`);
                    seenIds.add(id);
                    if (!name) errors.push(`Camera "${id || '(new)'}" must have a name.`);
                    if (!Number.isFinite(deviceNum) || deviceNum < 0) errors.push(`Camera "${id || '(new)'}" needs a non-negative device index.`);
                    if (portNum !== null) {
                        if (!Number.isFinite(portNum) || portNum <= 0) errors.push(`Camera "${id || '(new)'}" has an invalid port.`);
                        if (seenPorts.has(portNum)) errors.push(`Port ${portNum} is duplicated.`);
                        seenPorts.add(portNum);
                    }
                    if (widthNum !== null && (!Number.isFinite(widthNum) || widthNum <= 0)) errors.push(`Camera "${id || '(new)'}" width must be positive.`);
                    if (heightNum !== null && (!Number.isFinite(heightNum) || heightNum <= 0)) errors.push(`Camera "${id || '(new)'}" height must be positive.`);
                    if (fpsNum !== null && (!Number.isFinite(fpsNum) || fpsNum <= 0)) errors.push(`Camera "${id || '(new)'}" FPS must be positive.`);
                    if (brightnessNum !== null && !Number.isFinite(brightnessNum)) errors.push(`Camera "${id || '(new)'}" brightness must be numeric.`);
                    if (exposureNum !== null && !Number.isFinite(exposureNum)) errors.push(`Camera "${id || '(new)'}" exposure must be numeric.`);
                    if (whiteBalanceNum !== null && !Number.isFinite(whiteBalanceNum)) errors.push(`Camera "${id || '(new)'}" white balance must be numeric.`);

                    return { id, name, device: deviceNum, port: portNum, width: widthNum, height: heightNum, fps: fpsNum, brightness: brightnessNum, exposure: exposureNum, white_balance: whiteBalanceNum };
                }).filter(c => c.id);

                if (errors.length) {
                    setStatus(errors.join(' '), 'error');
                    return;
                }

                const payload = { host: document.getElementById('host').value || '0.0.0.0', cameras, auth: authCfg };
                setStatus('Saving‚Ä¶');
                try {
                    const headers = { 'Content-Type': 'application/json', ...buildAuthHeaders() };
                    const res = await fetch('/api/cameras', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload),
                    });
                    if (!res.ok) throw new Error((await res.json()).detail || await res.text());
                    await res.json();
                    setStatus('Saved! Cameras restarted and nginx config regenerated.', 'success');
                    setTimeout(() => location.href='/', 800);
                } catch (err) {
                    setStatus('Failed: ' + err, 'error');
                }
            }

            loadConfig();
        </script>
    """
    body = body.replace("__PROBE_MISSING__", str(PROBE_WHEN_NO_DEVICES).lower())
    body = body.replace("__PROBE_LIMIT__", str(MAX_DEVICE_PROBE))
    return _base_page("Settings ¬∑ Pi Camera Server", "settings", body)


@app.get("/api-docs", response_class=HTMLResponse, dependencies=[Depends(require_auth)])
def api_docs_page():
    host = CAMERA_CONFIG.get("host", DEFAULT_CAMERA_HOST)
    rows = []
    for cam in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam["id"]
        port = cam.get("port")
        rows.append(
            f"<tr><td>{cam_id}</td><td>/cam/{cam_id}/video</td><td>/cam/{cam_id}/snapshot</td><td>http://{host}:{port}/</td><td>http://{host}:{port}/snapshot</td></tr>"
        )

    body = f"""
        <div class='card'>
            <div class='pill'>üìò API</div>
            <h2 style='margin:8px 0 4px;'>HTTP endpoints</h2>
            <p class='muted'>Reference for integrating streams into dashboards or other services.</p>
            <h3>Configuration</h3>
            <ul>
                <li><code>GET /api/cameras</code> ‚Äî returns the current host and camera list.</li>
                <li><code>POST /api/cameras</code> ‚Äî update host and cameras; regenerates nginx.cameras.conf and restarts capture.</li>
                <li><code>DELETE /api/cameras/{{cam_id}}</code> ‚Äî remove a camera and restart capture.</li>
                <li><code>POST /api/cameras/{{cam_id}}/restart</code> ‚Äî manually restart one camera without editing config.</li>
                <li><code>GET /api/devices</code> ‚Äî list detected video devices and whether they are already assigned.</li>
                <li><code>GET /health</code> ‚Äî summary of camera states (online, stale, offline) and last frame ages.</li>
                <li><code>GET /metrics</code> ‚Äî Prometheus-style gauges for availability, subscribers, and frame ages.</li>
            </ul>
            <p class='muted'>Optional basic auth (configured in Settings) secures these endpoints and the Settings/API Docs pages; you can also opt-in to protecting streams.</p>
            <p class='muted'>Camera fields: <code>id</code>, <code>name</code>, <code>device</code>, optional <code>port</code>, <code>width</code>, <code>height</code>, <code>fps</code>, and optional controls <code>brightness</code>, <code>exposure</code>, <code>white_balance</code>.</p>
            <h3>Streaming</h3>
            <p class='muted'>Replace <code>{{cam_id}}</code> with a configured camera ID.</p>
            <ul>
                <li><code>/cam/{{cam_id}}/video</code> ‚Äî MJPEG stream (multipart/x-mixed-replace).</li>
                <li><code>/cam/{{cam_id}}/snapshot</code> ‚Äî single JPEG frame (returns an offline placeholder if the camera is unavailable).</li>
            </ul>
            <p class='muted'>Device discovery: <code>/api/devices?max=4&probe_missing=true</code> to scan a specific range when no <code>/dev/video*</code> entries are present.</p>
            <h3>Per-camera ports (Nginx proxy)</h3>
            <p class='muted'>Enable by including <code>nginx.cameras.conf</code> in your nginx configuration.</p>
            <table>
                <thead><tr><th>Camera</th><th>Video (API)</th><th>Snapshot (API)</th><th>Video (port)</th><th>Snapshot (port)</th></tr></thead>
                <tbody>{''.join(rows) if rows else '<tr><td colspan="5" class="muted">No cameras configured.</td></tr>'}</tbody>
            </table>
        </div>
    """
    return _base_page("API Docs ¬∑ Pi Camera Server", "docs", body)


@app.get("/api/devices", dependencies=[Depends(require_auth)])
def list_devices(max: Optional[int] = None, probe_missing: Optional[bool] = None):  # noqa: A002
    return {
        "devices": discover_cameras(
            max_devices=max, probe_when_empty=probe_missing
        )
    }


@app.get("/api/cameras", dependencies=[Depends(require_auth)])
def get_cameras():
    return CAMERA_CONFIG


@app.post("/api/cameras", dependencies=[Depends(require_auth)])
def set_cameras(data: CamerasUpdate):
    global CAMERA_CONFIG
    camera_dicts = [cam.model_dump() for cam in data.cameras]
    try:
        validate_auth(data.auth.model_dump())
        validate_camera_entries(camera_dicts)
    except ValueError as exc:  # noqa: BLE001
        raise HTTPException(status_code=400, detail=str(exc)) from exc

    CAMERA_CONFIG = {
        "host": data.host,
        "auth": data.auth.model_dump(),
        "cameras": assign_ports(camera_dicts),
    }
    save_config(CAMERA_CONFIG)
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    return {"status": "ok", "cameras": CAMERA_CONFIG}


@app.post("/api/cameras/{cam_id}/restart", dependencies=[Depends(require_auth)])
def restart_camera_endpoint(cam_id: str):
    return restart_camera(cam_id)


@app.delete("/api/cameras/{cam_id}", dependencies=[Depends(require_auth)])
def delete_camera(cam_id: str):
    global CAMERA_CONFIG
    cameras = [c for c in CAMERA_CONFIG.get("cameras", []) if c.get("id") != cam_id]
    if len(cameras) == len(CAMERA_CONFIG.get("cameras", [])):
        raise HTTPException(status_code=404, detail="Camera not configured")

    CAMERA_CONFIG["cameras"] = assign_ports(cameras)
    save_config(CAMERA_CONFIG)
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    return {"status": "deleted", "cameras": CAMERA_CONFIG["cameras"]}


@app.get("/health")
def health():
    statuses = camera_statuses()
    summary = {
        "total": len(statuses),
        "online": sum(1 for s in statuses if s.get("state") == "online"),
        "stale": sum(1 for s in statuses if s.get("state") == "stale"),
        "offline": sum(1 for s in statuses if s.get("state") == "offline"),
    }
    return {"status": "ok", "summary": summary, "cameras": statuses}


@app.get("/metrics")
def metrics():
    statuses = camera_statuses()
    lines = [
        "# HELP rpicam_camera_online Camera availability (1=online, 0=offline/stale)",
        "# TYPE rpicam_camera_online gauge",
    ]
    for st in statuses:
        val = 1 if st.get("state") == "online" else 0
        lines.append(f'rpicam_camera_online{{camera="{st.get("id")}"}} {val}')

    lines.extend(
        [
            "# HELP rpicam_camera_subscribers Active stream subscribers",
            "# TYPE rpicam_camera_subscribers gauge",
        ]
    )
    for st in statuses:
        subs = st.get("subscribers") or 0
        lines.append(f'rpicam_camera_subscribers{{camera="{st.get("id")}"}} {subs}')

    lines.extend(
        [
            "# HELP rpicam_camera_frame_age_seconds Age of last frame in seconds",
            "# TYPE rpicam_camera_frame_age_seconds gauge",
        ]
    )
    for st in statuses:
        age = st.get("last_frame_age")
        if age is None:
            continue
        lines.append(f'rpicam_camera_frame_age_seconds{{camera="{st.get("id")}"}} {age:.3f}')

    return Response("\n".join(lines) + "\n", media_type="text/plain; version=0.0.4")


@app.get("/cam/{cam_id}/video", dependencies=[Depends(require_stream_auth)])
async def video_stream(cam_id: str):
    return StreamingResponse(
        mjpeg_generator(cam_id),
        media_type="multipart/x-mixed-replace; boundary=frame",
    )


@app.get("/cam/{cam_id}/snapshot", dependencies=[Depends(require_stream_auth)])
async def snapshot(cam_id: str):
    img_bytes = await asyncio.to_thread(get_snapshot_bytes, cam_id)
    return Response(content=img_bytes, media_type="image/jpeg")


if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=APP_PORT, reload=False)
