"""
Raspberry Pi camera server exposing MJPEG video and snapshot endpoints per camera.

Run with uvicorn:
    uvicorn app:app --reload --host 0.0.0.0 --port 8000

The main FastAPI app provides configuration APIs and a basic viewer. Per-camera
ports are made available via an autogenerated Nginx configuration mapping to the
central FastAPI endpoints.
"""

import asyncio
import glob
import json
import logging
import os
import threading
import time
from logging.handlers import SysLogHandler
from pathlib import Path
from typing import Any, Dict, List, Optional

import cv2
import uvicorn
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, Response, StreamingResponse
from pydantic import BaseModel, Field

CONFIG_PATH = Path("cameras.json")
NGINX_CONFIG_PATH = Path("nginx.cameras.conf")
DEFAULT_CAMERA_HOST = "0.0.0.0"
DEFAULT_START_PORT = 8081
APP_PORT = int(os.getenv("APP_PORT", "8000"))

logger = logging.getLogger("rpicamserver")


def setup_logging() -> None:
    if logger.handlers:
        return

    logger.setLevel(logging.INFO)
    formatter = logging.Formatter(
        "%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    try:
        syslog_handler = SysLogHandler(address="/dev/log")
    except OSError:
        syslog_handler = None

    if syslog_handler:
        syslog_handler.setFormatter(formatter)
        logger.addHandler(syslog_handler)


setup_logging()

app = FastAPI(title="Raspberry Pi Camera Server")


###############################################################################
# Camera capture
###############################################################################


class Camera:
    """Background frame grabber for a single video device."""

    def __init__(
        self,
        device_index: int,
        width: Optional[int] = None,
        height: Optional[int] = None,
        fps: Optional[float] = None,
    ) -> None:
        self.device_index = device_index
        self.width = width
        self.height = height
        self.fps = fps
        self.capture_interval = 1 / float(fps or 30.0)
        self.idle_wait = 5.0
        self.active_subscribers = 0
        self.idle_event = threading.Event()
        self.last_frame_ts = 0.0
        self.failure_count = 0

        self.cap = self._open_capture()

        self.frame_lock = threading.Lock()
        self.latest_frame = None
        self.running = True

        self.thread = threading.Thread(target=self._update_loop, daemon=True)
        self.thread.start()

    def _open_capture(self) -> cv2.VideoCapture:
        cap = cv2.VideoCapture(self.device_index)
        if not cap.isOpened():
            cap.release()
            raise RuntimeError(f"Could not open camera device {self.device_index}")

        if self.width:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, int(self.width))
        if self.height:
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, int(self.height))
        if self.fps:
            cap.set(cv2.CAP_PROP_FPS, float(self.fps))
        return cap

    def add_subscriber(self) -> None:
        self.active_subscribers += 1
        self.idle_event.set()

    def remove_subscriber(self) -> None:
        self.active_subscribers = max(0, self.active_subscribers - 1)
        if self.active_subscribers == 0:
            self.idle_event.set()

    def _restart_capture(self) -> None:
        try:
            self.cap.release()
        except Exception:  # noqa: BLE001
            pass

        self.cap = None

        try:
            self.cap = self._open_capture()
            self.failure_count = 0
            self.idle_event.set()
            logger.info("Restarted camera device %s", self.device_index)
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to restart camera %s: %s", self.device_index, exc)

    def _update_loop(self) -> None:
        while self.running:
            if not self.cap or not self.cap.isOpened():
                self._restart_capture()
                time.sleep(0.5)
                continue

            if self.active_subscribers <= 0:
                self.idle_event.clear()
                self.idle_event.wait(timeout=self.idle_wait)
                # continue to read once to keep snapshots fresh when prompted

            ret, frame = self.cap.read()
            if not ret:
                self.failure_count += 1
                if self.failure_count >= 5:
                    self._restart_capture()
                time.sleep(0.25)
                continue

            self.failure_count = 0
            with self.frame_lock:
                self.latest_frame = frame
                self.last_frame_ts = time.time()

            time.sleep(self.capture_interval)

    def get_frame(self, wait: bool = False, timeout: float = 1.0):
        if wait:
            self.idle_event.set()
            deadline = time.time() + timeout
            while time.time() < deadline:
                with self.frame_lock:
                    if self.latest_frame is not None:
                        return self.latest_frame.copy()
                time.sleep(0.05)
            return None

        with self.frame_lock:
            if self.latest_frame is None:
                return None
            return self.latest_frame.copy()

    def stop(self) -> None:
        self.running = False
        self.idle_event.set()
        self.thread.join(timeout=1)
        self.cap.release()


def _encode_frame(frame, quality: int = 80) -> Optional[bytes]:
    ret, jpeg = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), quality])
    if not ret:
        return None
    return jpeg.tobytes()


###############################################################################
# Configuration
###############################################################################


def default_config() -> Dict[str, Any]:
    return {"host": DEFAULT_CAMERA_HOST, "cameras": []}


def validate_camera_entries(cameras: List[Dict[str, Any]]) -> None:
    """Validate required camera fields and uniqueness constraints."""

    seen_ids: set[str] = set()
    seen_ports: set[int] = set()

    for cam in cameras:
        cam_id = str(cam.get("id", "")).strip()
        name = str(cam.get("name", "")).strip()
        device = cam.get("device")
        port = cam.get("port")
        width = cam.get("width")
        height = cam.get("height")
        fps = cam.get("fps")

        if not cam_id:
            raise ValueError("Camera id is required.")
        if cam_id in seen_ids:
            raise ValueError(f"Duplicate camera id '{cam_id}' is not allowed.")
        if not name:
            raise ValueError(f"Camera '{cam_id}' must have a name.")
        if device is None or device < 0:
            raise ValueError(f"Camera '{cam_id}' requires a non-negative device index.")
        if width is not None and width <= 0:
            raise ValueError(f"Camera '{cam_id}' width must be positive when provided.")
        if height is not None and height <= 0:
            raise ValueError(f"Camera '{cam_id}' height must be positive when provided.")
        if fps is not None and fps <= 0:
            raise ValueError(f"Camera '{cam_id}' fps must be positive when provided.")
        if port is not None:
            if port <= 0:
                raise ValueError(f"Camera '{cam_id}' has an invalid port: {port}.")
            if port in seen_ports:
                raise ValueError(f"Duplicate port {port} is not allowed; leave blank to auto-assign.")
            seen_ports.add(port)

        seen_ids.add(cam_id)


def load_config() -> Dict[str, Any]:
    if CONFIG_PATH.exists():
        config = json.loads(CONFIG_PATH.read_text())
    else:
        config = default_config()

    assigned_cameras = assign_ports(config.get("cameras", []))
    try:
        validate_camera_entries(assigned_cameras)
    except ValueError as exc:  # noqa: BLE001
        logger.warning("Invalid camera configuration: %s. Resetting to defaults.", exc)
        config = default_config()
        assigned_cameras = []

    if assigned_cameras != config.get("cameras", []):
        config["cameras"] = assigned_cameras
        save_config(config)
    else:
        config["cameras"] = assigned_cameras
    return config


def save_config(config: Dict[str, Any]) -> None:
    CONFIG_PATH.write_text(json.dumps(config, indent=2))


def assign_ports(cameras: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Ensure each camera has a unique port, auto-assigning if omitted or duplicated."""

    assigned: List[Dict[str, Any]] = []
    used_ports: set[int] = set()
    next_port = DEFAULT_START_PORT

    for cam in cameras:
        cam_copy = dict(cam)
        port = cam_copy.get("port")

        if port is not None:
            # Keep user-provided ports when available and unused.
            if port in used_ports:
                next_port = max(next_port, port + 1)
                port = None
            else:
                used_ports.add(port)
                next_port = max(next_port, port + 1)

        if port is None:
            while next_port in used_ports:
                next_port += 1
            port = next_port
            used_ports.add(port)
            next_port += 1

        cam_copy["port"] = port
        assigned.append(cam_copy)

    return assigned


def discover_cameras(max_devices: int = 10) -> List[Dict[str, Any]]:
    """Probe video capture devices and return detected indices and metadata."""

    discovered: List[Dict[str, Any]] = []
    used_devices = {cam.get("device") for cam in CAMERA_CONFIG.get("cameras", [])}
    existing_nodes = sorted({int(Path(dev).name.replace("video", "")) for dev in glob.glob("/dev/video*") if Path(dev).name.replace("video", "").isdigit()})
    probe_indices = existing_nodes or list(range(max_devices))

    for idx in probe_indices:
        cap = cv2.VideoCapture(idx)
        if not cap.isOpened():
            cap.release()
            continue

        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH) or 0)
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT) or 0)
        fps = float(cap.get(cv2.CAP_PROP_FPS) or 0.0)
        cap.release()

        discovered.append(
            {
                "index": idx,
                "in_use": idx in used_devices,
                "resolution": {
                    "width": width or None,
                    "height": height or None,
                },
                "fps": fps or None,
            }
        )

    return discovered


def generate_nginx_config(config: Dict[str, Any], output_path: Path = NGINX_CONFIG_PATH) -> None:
    """Write an nginx config mapping per-camera ports to the main API."""

    lines = [
        "# Auto-generated by app.py. Include this file from nginx.conf or conf.d.",
        "# Reload nginx after updating the camera configuration.",
        "",
    ]

    for cam in config.get("cameras", []):
        cam_id = cam["id"]
        port = cam["port"]
        lines.extend(
            [
                "server {",
                f"    listen {port};",
                "    location / {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/video;",
                "        proxy_set_header Host $host;",
                "    }",
                "    location /snapshot {",
                f"        proxy_pass http://127.0.0.1:{APP_PORT}/cam/{cam_id}/snapshot;",
                "        proxy_set_header Host $host;",
                "    }",
                "}",
                "",
            ]
        )

    output_path.write_text("\n".join(lines))


###############################################################################
# Models
###############################################################################


class CameraConfig(BaseModel):
    id: str = Field(description="Unique camera identifier")
    name: str
    device: int = Field(description="cv2.VideoCapture device index")
    port: Optional[int] = Field(
        default=None, description="Port for the per-camera proxy (via Nginx)"
    )
    width: Optional[int] = Field(default=None, description="Capture width")
    height: Optional[int] = Field(default=None, description="Capture height")
    fps: Optional[float] = Field(default=None, description="Requested FPS")


class CamerasUpdate(BaseModel):
    host: str = Field(default=DEFAULT_CAMERA_HOST, description="Binding host")
    cameras: List[CameraConfig]


###############################################################################
# App state helpers
###############################################################################


CAMERAS: Dict[str, Camera] = {}
CAMERA_CONFIG: Dict[str, Any] = default_config()


def stop_cameras() -> None:
    for camera in CAMERAS.values():
        camera.stop()
    CAMERAS.clear()


def init_cameras() -> None:
    stop_cameras()

    for cam_cfg in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam_cfg["id"]
        device_index = cam_cfg["device"]
        width = cam_cfg.get("width")
        height = cam_cfg.get("height")
        fps = cam_cfg.get("fps")

        try:
            camera = Camera(device_index, width=width, height=height, fps=fps)
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to start camera %s: %s", cam_id, exc)
            continue

        CAMERAS[cam_id] = camera
        logger.info("Started camera %s on device %s", cam_id, device_index)


###############################################################################
# Shared streaming helpers for the main API
###############################################################################


async def mjpeg_generator(cam_id: str):
    if cam_id not in CAMERAS:
        raise HTTPException(status_code=404, detail="Camera not found")

    camera = CAMERAS[cam_id]
    boundary = "frame"
    camera.add_subscriber()

    try:
        while True:
            frame = await asyncio.to_thread(camera.get_frame, True, 1.0)
            if frame is None:
                await asyncio.sleep(0.1)
                continue

            jpg_bytes = _encode_frame(frame, quality=80)
            if jpg_bytes is None:
                await asyncio.sleep(camera.capture_interval)
                continue

            yield (
                b"--" + boundary.encode() + b"\r\n"
                b"Content-Type: image/jpeg\r\n\r\n" + jpg_bytes + b"\r\n"
            )
            await asyncio.sleep(camera.capture_interval)
    finally:
        camera.remove_subscriber()


def get_snapshot_bytes(cam_id: str) -> bytes:
    if cam_id not in CAMERAS:
        raise HTTPException(status_code=404, detail="Camera not found")
    frame = CAMERAS[cam_id].get_frame(wait=True, timeout=1.5)
    if frame is None:
        raise HTTPException(status_code=503, detail="No frame available yet")

    jpg_bytes = _encode_frame(frame, quality=90)
    if jpg_bytes is None:
        raise HTTPException(status_code=500, detail="Failed to encode frame")
    return jpg_bytes


###############################################################################
# API endpoints
###############################################################################


@app.on_event("startup")
def startup_event() -> None:
    global CAMERA_CONFIG
    CAMERA_CONFIG = load_config()
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    logger.info("Camera server started with %d configured camera(s)", len(CAMERA_CONFIG.get("cameras", [])))


@app.on_event("shutdown")
def shutdown_event() -> None:
    logger.info("Shutting down camera server")
    stop_cameras()


def _base_page(title: str, active: str, body: str) -> str:
    nav_items = {
        "home": ("/", "Cameras"),
        "settings": ("/settings", "Settings"),
        "docs": ("/api-docs", "API Docs"),
    }

    nav_html = "".join(
        f"<a class='{'nav-link active' if key == active else 'nav-link'}' href='{href}'>"
        f"{label}</a>" for key, (href, label) in nav_items.items()
    )

    template = """
    <html>
    <head>
        <title>__TITLE__</title>
        <meta charset=\"utf-8\" />
        <style>
            :root {
                color-scheme: light dark;
                --bg: #0f172a;
                --panel: #111827;
                --accent: #3b82f6;
                --text: #e5e7eb;
                --muted: #94a3b8;
                --border: #1f2937;
                font-family: 'Inter', system-ui, -apple-system, sans-serif;
            }
            body {
                margin: 0 auto;
                max-width: 1100px;
                padding: 24px 16px 48px;
                color: var(--text);
                background: linear-gradient(180deg, #0b1224 0%, #0f172a 35%, #0f172a 100%);
            }
            h1 { margin: 0 0 16px; letter-spacing: -0.02em; }
            p { color: var(--muted); }
            .nav {
                display: flex;
                gap: 12px;
                margin: 16px 0 24px;
                border-bottom: 1px solid var(--border);
                padding-bottom: 10px;
            }
            .nav-link {
                color: var(--muted);
                text-decoration: none;
                padding: 8px 12px;
                border-radius: 8px;
                transition: background 0.15s, color 0.15s;
            }
            .nav-link:hover { color: var(--text); background: #111827; }
            .nav-link.active {
                background: rgba(59, 130, 246, 0.15);
                color: #bfdbfe;
                border: 1px solid rgba(59, 130, 246, 0.4);
            }
            .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
            .card {
                background: var(--panel);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.25);
            }
            .pill {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                background: rgba(59, 130, 246, 0.1);
                color: #bfdbfe;
                padding: 6px 10px;
                border-radius: 999px;
                font-size: 12px;
                border: 1px solid rgba(59,130,246,0.25);
            }
            code { background: rgba(255,255,255,0.04); padding: 2px 4px; border-radius: 6px; }
            .btn {
                background: var(--accent);
                color: white;
                padding: 10px 14px;
                border-radius: 10px;
                border: none;
                cursor: pointer;
                font-weight: 600;
                box-shadow: 0 10px 30px rgba(59,130,246,0.25);
            }
            .btn-secondary {
                background: #1f2937;
                color: var(--text);
                border: 1px solid var(--border);
            }
            .input, select {
                width: 100%;
                padding: 10px 12px;
                border-radius: 10px;
                border: 1px solid var(--border);
                background: #0b1224;
                color: var(--text);
            }
            table { width: 100%; border-collapse: collapse; margin-top: 12px; }
            th, td { text-align: left; padding: 8px; border-bottom: 1px solid var(--border); }
            .muted { color: var(--muted); font-size: 14px; }
            .status { margin-top: 12px; font-weight: 600; }
            .status.error { color: #fca5a5; }
            .status.success { color: #a7f3d0; }
            a { color: #93c5fd; }
        </style>
    </head>
    <body>
        <h1>Pi Camera Server</h1>
        <div class=\"nav\">__NAV__</div>
        __BODY__
    </body>
    </html>
    """

    return (
        template.replace("__NAV__", nav_html)
        .replace("__BODY__", body)
        .replace("__TITLE__", title)
    )


@app.get("/", response_class=HTMLResponse)
def index_page():
    host = CAMERA_CONFIG.get("host", DEFAULT_CAMERA_HOST)
    cards = []
    for cam in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam["id"]
        port = cam.get("port")
        name = cam.get("name", cam_id)
        width = cam.get("width")
        height = cam.get("height")
        fps = cam.get("fps")
        res_text = (
            f"{width}√ó{height}"
            if width and height
            else "Default resolution"
        )
        if fps:
            res_text += f" @ {fps} fps"
        cards.append(
            f"""
            <div class='card'>
                <div style='display:flex; justify-content: space-between; align-items:center;'>
                    <div>
                        <div class='pill'>üé• Camera ¬∑ {cam_id}</div>
                        <h3 style='margin:8px 0 4px;'>{name}</h3>
                        <p class='muted'>Device index: {cam['device']}</p>
                        <p class='muted'>Capture: {res_text}</p>
                    </div>
                    <div style='text-align:right;'>
                        <div class='muted'>Port</div>
                        <div style='font-weight:700;'>:{port}</div>
                    </div>
                </div>
                <div style='margin:12px 0;'>
                    <img src='/cam/{cam_id}/video' style='width:100%; border:1px solid var(--border); border-radius:10px;'>
                </div>
                <div style='display:flex; gap:12px; align-items:center; flex-wrap:wrap;'>
                    <img id='snap-{cam_id}' src='/cam/{cam_id}/snapshot' style='width:140px; border:1px solid var(--border); border-radius:8px;'>
                    <div>
                        <div class='muted'>Main API</div>
                        <code>/cam/{cam_id}/video</code><br>
                        <code>/cam/{cam_id}/snapshot</code>
                        <div style='margin-top:6px;' class='muted'>Nginx mapped:</div>
                        <code>http://{host}:{port}/</code><br>
                        <code>http://{host}:{port}/snapshot</code>
                    </div>
                </div>
            </div>
            """
        )

    body = f"""
        <p class='muted'>Streams are available via the main API and per-camera ports generated in nginx.cameras.conf.</p>
        <div class='card-grid'>
            {''.join(cards) if cards else '<div class="card"><p>No cameras configured yet. Add one in Settings.</p></div>'}
        </div>
        <script>
            setInterval(() => {{
                const imgs = document.querySelectorAll("img[id^='snap-']");
                imgs.forEach(img => {{
                    const base = img.src.split('?')[0];
                    img.src = base + "?t=" + Date.now();
                }});
            }}, 2000);
        </script>
    """

    return _base_page("Pi Camera Server", "home", body)


@app.get("/settings", response_class=HTMLResponse)
def settings_page():
    body = """
        <div class='card'>
            <div style='display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;'>
                <div>
                    <div class='pill'>‚öôÔ∏è Setup</div>
                    <h2 style='margin:8px 0 4px;'>Camera configuration</h2>
                    <p class='muted'>Edit the host and cameras, then save to regenerate nginx.cameras.conf and restart capture threads.</p>
                </div>
                <button class='btn' onclick='saveConfig()'>üíæ Save changes</button>
            </div>
            <div style='margin-top:16px;'>
                <label class='muted'>Binding host</label>
                <input class='input' id='host' placeholder='0.0.0.0'>
            </div>
            <div style='margin-top:16px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;'>
                <div>
                    <h3 style='margin:0;'>Cameras</h3>
                    <p class='muted' style='margin:4px 0 0;'>Pick from unused devices when adding a new entry.</p>
                </div>
                <div style='display:flex; gap:8px; flex-wrap:wrap;'>
                    <button class='btn-secondary btn' onclick='refreshDevices()'>‚Üª Rescan devices</button>
                    <button class='btn-secondary btn' onclick='addRow()'>Ôºã Add camera</button>
                </div>
            </div>
            <div id='device-list' style='margin:10px 0 12px;'></div>
            <div style='overflow-x:auto;'>
                <table id='cam-table'>
                    <thead>
                        <tr><th>ID</th><th>Name</th><th>Device</th><th>Port</th><th>Width</th><th>Height</th><th>FPS</th><th></th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div id='status' class='status muted'></div>
        </div>
        <script>
            const tbody = document.querySelector('#cam-table tbody');
            const status = document.getElementById('status');
            let devices = [];

            function setStatus(text, variant='muted') {
                status.textContent = text;
                status.classList.remove('error', 'success', 'muted');
                status.classList.add(variant);
            }

            function renderDeviceOptions(currentDevice) {
                if (!devices.length) {
                    const val = currentDevice ?? '';
                    return `<option value="${val}">${val === '' ? 'Enter a device number' : 'Device ' + val}</option>`;
                }

                const options = devices.map(dev => {
                    const disabled = dev.in_use && dev.index !== currentDevice;
                    const res = (dev.resolution?.width && dev.resolution?.height)
                        ? `${dev.resolution.width}√ó${dev.resolution.height}`
                        : 'resolution unknown';
                    const fpsText = dev.fps ? ` ¬∑ ${dev.fps.toFixed(1)} fps` : '';
                    return `<option value="${dev.index}" ${dev.index === currentDevice ? 'selected' : ''} ${disabled ? 'disabled' : ''}>${dev.index} ¬∑ ${res}${fpsText}${dev.in_use && dev.index !== currentDevice ? ' (in use)' : ''}</option>`;
                }).join('');

                const fallback = (currentDevice !== null && currentDevice !== '' && !devices.some(d => d.index === currentDevice))
                    ? `<option value="${currentDevice}" selected>Device ${currentDevice}</option>`
                    : '';

                return `<option value="">Select device‚Ä¶</option>${options}${fallback}`;
            }

            function updateDeviceSelects() {
                const selects = tbody.querySelectorAll('select.device-select');
                selects.forEach(sel => {
                    const currentVal = sel.value === '' ? '' : Number(sel.value);
                    sel.innerHTML = renderDeviceOptions(Number.isNaN(currentVal) ? '' : currentVal);
                    sel.value = sel.dataset.current = sel.value || (Number.isNaN(currentVal) ? '' : currentVal);
                });
            }

            function addRow(cam={id:'', name:'', device:'', port:'', width:'', height:'', fps:''}) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input class='input' value='${cam.id}' placeholder='cam1'></td>
                    <td><input class='input' value='${cam.name}' placeholder='USB Cam'></td>
                    <td><select class='input device-select' data-current='${cam.device ?? ''}'></select></td>
                    <td><input class='input' value='${cam.port ?? ''}' type='number' min='0' style='width:100px'></td>
                    <td><input class='input' value='${cam.width ?? ''}' type='number' min='0' style='width:100px' placeholder='auto'></td>
                    <td><input class='input' value='${cam.height ?? ''}' type='number' min='0' style='width:100px' placeholder='auto'></td>
                    <td><input class='input' value='${cam.fps ?? ''}' type='number' min='0' step='0.1' style='width:100px' placeholder='auto'></td>
                    <td style='width:60px; text-align:right;'><button class='btn-secondary btn' onclick='this.closest("tr").remove(); updateDeviceSelects();'>‚úñ</button></td>
                `;
                tbody.appendChild(tr);
                updateDeviceSelects();
            }

            async function loadConfig() {
                try {
                    const res = await fetch('/api/cameras');
                    const data = await res.json();
                    document.querySelector('#host').value = data.host || '';
                    tbody.innerHTML = '';
                    (data.cameras || []).forEach(addRow);
                    await refreshDevices(false);
                    setStatus('Loaded configuration.');
                } catch (err) {
                    setStatus('Failed to load configuration: ' + err, 'error');
                }
            }

            async function refreshDevices(showStatus=true) {
                if (showStatus) setStatus('Scanning for connected cameras‚Ä¶');
                try {
                    const res = await fetch('/api/devices');
                    const data = await res.json();
                    devices = data.devices || [];
                    renderDeviceList();
                    updateDeviceSelects();
                    if (showStatus) setStatus('Camera scan complete.');
                } catch (err) {
                    if (showStatus) setStatus('Failed to scan devices: ' + err, 'error');
                }
            }

            function renderDeviceList() {
                const container = document.getElementById('device-list');
                if (!devices.length) {
                    container.innerHTML = '<p class="muted">No cameras detected. You can still enter a device number manually.</p>';
                    return;
                }

                const rows = devices.map(dev => {
                    const res = (dev.resolution?.width && dev.resolution?.height)
                        ? `${dev.resolution.width}√ó${dev.resolution.height}`
                        : 'unknown';
                    const fps = dev.fps ? `${dev.fps.toFixed(1)} fps` : 'unknown';
                    const dim = dev.in_use ? 'style="opacity:0.45;"' : '';
                    const action = dev.in_use
                        ? '<span class="pill" style="background:rgba(148,163,184,0.15); color:#cbd5e1; border-color:rgba(148,163,184,0.35);">In use</span>'
                        : `<button class='btn-secondary btn' onclick='addFromDevice(${dev.index})'>Add</button>`;
                    return `<tr ${dim}><td>${dev.index}</td><td>${res}</td><td>${fps}</td><td>${action}</td></tr>`;
                }).join('');

                container.innerHTML = `<table><thead><tr><th>Device</th><th>Resolution</th><th>FPS</th><th></th></tr></thead><tbody>${rows}</tbody></table>`;
            }

            function addFromDevice(index) {
                const existing = Array.from(tbody.querySelectorAll('tr')).some(row => {
                    const deviceVal = row.querySelector('select.device-select')?.value;
                    return deviceVal !== '' && Number(deviceVal) === index;
                });
                if (existing) return;
                addRow({ id: `cam${index}`, name: `Camera ${index}`, device: index, port: '', width: '', height: '', fps: '' });
                setStatus(`Added device ${index} to the table.`);
            }

            async function saveConfig() {
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const errors = [];
                const seenIds = new Set();
                const seenPorts = new Set();

                const cameras = rows.map(r => {
                    const inputs = Array.from(r.querySelectorAll('input'));
                    const [id,name,port,width,height,fps] = inputs.map(i => i.value.trim());
                    const deviceSelect = r.querySelector('select');
                    const device = deviceSelect ? deviceSelect.value.trim() : '';
                    const deviceNum = device === '' ? NaN : Number(device);
                    const portNum = port === '' ? null : Number(port);
                    const widthNum = width === '' ? null : Number(width);
                    const heightNum = height === '' ? null : Number(height);
                    const fpsNum = fps === '' ? null : Number(fps);

                    if (!id) errors.push('Camera ID is required.');
                    if (id && seenIds.has(id)) errors.push(`Duplicate camera id "${id}".`);
                    seenIds.add(id);
                    if (!name) errors.push(`Camera "${id || '(new)'}" must have a name.`);
                    if (!Number.isFinite(deviceNum) || deviceNum < 0) errors.push(`Camera "${id || '(new)'}" needs a non-negative device index.`);
                    if (portNum !== null) {
                        if (!Number.isFinite(portNum) || portNum <= 0) errors.push(`Camera "${id || '(new)'}" has an invalid port.`);
                        if (seenPorts.has(portNum)) errors.push(`Port ${portNum} is duplicated.`);
                        seenPorts.add(portNum);
                    }
                    if (widthNum !== null && (!Number.isFinite(widthNum) || widthNum <= 0)) errors.push(`Camera "${id || '(new)'}" width must be positive.`);
                    if (heightNum !== null && (!Number.isFinite(heightNum) || heightNum <= 0)) errors.push(`Camera "${id || '(new)'}" height must be positive.`);
                    if (fpsNum !== null && (!Number.isFinite(fpsNum) || fpsNum <= 0)) errors.push(`Camera "${id || '(new)'}" FPS must be positive.`);

                    return { id, name, device: deviceNum, port: portNum, width: widthNum, height: heightNum, fps: fpsNum };
                }).filter(c => c.id);

                if (errors.length) {
                    setStatus(errors.join(' '), 'error');
                    return;
                }

                const payload = { host: document.getElementById('host').value || '0.0.0.0', cameras };
                setStatus('Saving‚Ä¶');
                try {
                    const res = await fetch('/api/cameras', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });
                    if (!res.ok) throw new Error((await res.json()).detail || await res.text());
                    await res.json();
                    setStatus('Saved! Cameras restarted and nginx config regenerated.', 'success');
                    setTimeout(() => location.href='/', 800);
                } catch (err) {
                    setStatus('Failed: ' + err, 'error');
                }
            }

            loadConfig();
        </script>
    """
    return _base_page("Settings ¬∑ Pi Camera Server", "settings", body)


@app.get("/api-docs", response_class=HTMLResponse)
def api_docs_page():
    host = CAMERA_CONFIG.get("host", DEFAULT_CAMERA_HOST)
    rows = []
    for cam in CAMERA_CONFIG.get("cameras", []):
        cam_id = cam["id"]
        port = cam.get("port")
        rows.append(
            f"<tr><td>{cam_id}</td><td>/cam/{cam_id}/video</td><td>/cam/{cam_id}/snapshot</td><td>http://{host}:{port}/</td><td>http://{host}:{port}/snapshot</td></tr>"
        )

    body = f"""
        <div class='card'>
            <div class='pill'>üìò API</div>
            <h2 style='margin:8px 0 4px;'>HTTP endpoints</h2>
            <p class='muted'>Reference for integrating streams into dashboards or other services.</p>
            <h3>Configuration</h3>
            <ul>
                <li><code>GET /api/cameras</code> ‚Äî returns the current host and camera list.</li>
                <li><code>POST /api/cameras</code> ‚Äî update host and cameras; regenerates nginx.cameras.conf and restarts capture.</li>
                <li><code>GET /api/devices</code> ‚Äî list detected video devices and whether they are already assigned.</li>
            </ul>
            <p class='muted'>Camera fields: <code>id</code>, <code>name</code>, <code>device</code>, optional <code>port</code>, <code>width</code>, <code>height</code>, and <code>fps</code>.</p>
            <h3>Streaming</h3>
            <p class='muted'>Replace <code>{{cam_id}}</code> with a configured camera ID.</p>
            <ul>
                <li><code>/cam/{{cam_id}}/video</code> ‚Äî MJPEG stream (multipart/x-mixed-replace).</li>
                <li><code>/cam/{{cam_id}}/snapshot</code> ‚Äî single JPEG frame.</li>
            </ul>
            <h3>Per-camera ports (Nginx proxy)</h3>
            <p class='muted'>Enable by including <code>nginx.cameras.conf</code> in your nginx configuration.</p>
            <table>
                <thead><tr><th>Camera</th><th>Video (API)</th><th>Snapshot (API)</th><th>Video (port)</th><th>Snapshot (port)</th></tr></thead>
                <tbody>{''.join(rows) if rows else '<tr><td colspan="5" class="muted">No cameras configured.</td></tr>'}</tbody>
            </table>
        </div>
    """
    return _base_page("API Docs ¬∑ Pi Camera Server", "docs", body)


@app.get("/api/devices")
def list_devices():
    return {"devices": discover_cameras()}


@app.get("/api/cameras")
def get_cameras():
    return CAMERA_CONFIG


@app.post("/api/cameras")
def set_cameras(data: CamerasUpdate):
    global CAMERA_CONFIG
    camera_dicts = [cam.model_dump() for cam in data.cameras]
    try:
        validate_camera_entries(camera_dicts)
    except ValueError as exc:  # noqa: BLE001
        raise HTTPException(status_code=400, detail=str(exc)) from exc

    CAMERA_CONFIG = {"host": data.host, "cameras": assign_ports(camera_dicts)}
    save_config(CAMERA_CONFIG)
    init_cameras()
    generate_nginx_config(CAMERA_CONFIG)
    return {"status": "ok", "cameras": CAMERA_CONFIG}


@app.get("/cam/{cam_id}/video")
async def video_stream(cam_id: str):
    return StreamingResponse(
        mjpeg_generator(cam_id),
        media_type="multipart/x-mixed-replace; boundary=frame",
    )


@app.get("/cam/{cam_id}/snapshot")
async def snapshot(cam_id: str):
    img_bytes = await asyncio.to_thread(get_snapshot_bytes, cam_id)
    return Response(content=img_bytes, media_type="image/jpeg")


if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=APP_PORT, reload=False)
